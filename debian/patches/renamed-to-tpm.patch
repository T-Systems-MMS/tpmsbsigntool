Description: Renamed tools to tpm namespace
Author: Richard Robert Reitz <richard-robert.reitz@t-systems.com>

Renamed sbsign and kmodsign to tpmsbsign and tpmkmodsign. Deleted all other source files.

---

--- tpmsbsigntool-0.9.4.orig/Makefile.am
+++ tpmsbsigntool-0.9.4/Makefile.am
@@ -1,2 +1,2 @@
 
-SUBDIRS = lib/ccan src docs tests
+SUBDIRS = lib/ccan src docs
--- tpmsbsigntool-0.9.4.orig/configure.ac
+++ tpmsbsigntool-0.9.4/configure.ac
@@ -1,11 +1,11 @@
-AC_INIT([sbsigntool], [0.9.4], [James.Bottomley@HansenPartnership.com])
+AC_INIT([tpmsbsigntool], [0.9.4], [James.Bottomley@HansenPartnership.com])
 
 AM_INIT_AUTOMAKE()
 
 AC_PREREQ(2.60)
 
 AC_CONFIG_HEADERS(config.h)
-AC_CONFIG_SRCDIR(src/sbsign.c)
+AC_CONFIG_SRCDIR(src/tpmsbsign.c)
 
 AM_PROG_AS
 AC_PROG_CC
@@ -91,5 +91,5 @@ AC_SUBST(EFI_ARCH, $EFI_ARCH)
 AC_SUBST(CRTPATH, $CRTPATH)
 
 AC_CONFIG_FILES([Makefile src/Makefile lib/ccan/Makefile]
-		[docs/Makefile tests/Makefile])
+		[docs/Makefile])
 AC_OUTPUT
--- tpmsbsigntool-0.9.4.orig/docs/Makefile.am
+++ tpmsbsigntool-0.9.4/docs/Makefile.am
@@ -1,9 +1,7 @@
 
-man1_MANS = sbsign.1 sbverify.1 sbattach.1 sbvarsign.1 sbsiglist.1 \
-		sbkeysync.1
+man1_MANS = tpmsbsign.1 tpmkmodsign.1
 
-EXTRA_DIST = sbsign.1.in sbverify.1.in sbattach.1.in \
-		sbvarsign.1.in sbsiglist.1.in sbkeysync.1.in
+EXTRA_DIST = tpmsbsign.1.in tpmkmodsign.1.in
 CLEANFILES = $(man1_MANS)
 
 $(builddir)/%.1: $(srcdir)/%.1.in $(top_builddir)/src/%
--- tpmsbsigntool-0.9.4.orig/docs/sbattach.1.in
+++ /dev/null
@@ -1,2 +0,0 @@
-[name]
-sbattach - UEFI secure boot detached signature tool
--- tpmsbsigntool-0.9.4.orig/docs/sbkeysync.1.in
+++ /dev/null
@@ -1,2 +0,0 @@
-[name]
-sbkeysync - UEFI secure boot key synchronization tool
--- tpmsbsigntool-0.9.4.orig/docs/sbsiglist.1.in
+++ /dev/null
@@ -1,2 +0,0 @@
-[name]
-sbsiglist - Create EFI_SIGNATURE_LIST signature databases
--- tpmsbsigntool-0.9.4.orig/docs/sbsign.1.in
+++ /dev/null
@@ -1,2 +0,0 @@
-[name]
-sbsign - UEFI secure boot signing tool
--- tpmsbsigntool-0.9.4.orig/docs/sbvarsign.1.in
+++ /dev/null
@@ -1,2 +0,0 @@
-[name]
-sbvarsign - UEFI authenticated variable signing tool
--- tpmsbsigntool-0.9.4.orig/docs/sbverify.1.in
+++ /dev/null
@@ -1,2 +0,0 @@
-[name]
-sbverify - UEFI secure boot verification tool
--- /dev/null
+++ tpmsbsigntool-0.9.4/docs/tpmkmodsign.1.in
@@ -0,0 +1,2 @@
+[name]
+tpmkmodsign - TPM Kernel module signing tool
--- /dev/null
+++ tpmsbsigntool-0.9.4/docs/tpmsbsign.1.in
@@ -0,0 +1,2 @@
+[name]
+tpmsbsign - TPM UEFI secure boot signing tool
--- tpmsbsigntool-0.9.4.orig/src/Makefile.am
+++ tpmsbsigntool-0.9.4/src/Makefile.am
@@ -1,5 +1,5 @@
 
-bin_PROGRAMS = sbsign sbverify sbattach sbvarsign sbsiglist sbkeysync
+bin_PROGRAMS = tpmsbsign tpmkmodsign
 
 coff_headers = coff/external.h coff/pe.h
 AM_CFLAGS = -Wall -Wextra --std=gnu99 -Wno-error=deprecated-declarations -Werror=incompatible-pointer-types
@@ -9,29 +9,10 @@ common_SOURCES = idc.c idc.h image.c ima
 common_LDADD = ../lib/ccan/libccan.a $(libcrypto_LIBS)
 common_CFLAGS = -I$(top_srcdir)/lib/ccan/ -Werror
 
-sbsign_SOURCES = sbsign.c $(common_SOURCES)
-sbsign_LDADD = $(common_LDADD)
-sbsign_CFLAGS = $(AM_CFLAGS) $(common_CFLAGS)
-
-sbverify_SOURCES = sbverify.c $(common_SOURCES)
-sbverify_LDADD = $(common_LDADD)
-sbverify_CFLAGS = $(AM_CFLAGS) $(common_CFLAGS)
-
-sbattach_SOURCES = sbattach.c $(common_SOURCES)
-sbattach_LDADD = $(common_LDADD)
-sbattach_CFLAGS = $(AM_CFLAGS) $(common_CFLAGS)
-
-sbvarsign_SOURCES = sbvarsign.c $(common_SOURCES)
-sbvarsign_LDADD = $(common_LDADD) $(uuid_LIBS)
-sbvarsign_CPPFLAGS = $(EFI_CPPFLAGS)
-sbvarsign_CFLAGS = $(AM_CFLAGS) $(uuid_CFLAGS) $(common_CFLAGS)
-
-sbsiglist_SOURCES = sbsiglist.c $(common_SOURCES)
-sbsiglist_LDADD = $(common_LDADD) $(uuid_LIBS)
-sbsiglist_CPPFLAGS = $(EFI_CPPFLAGS)
-sbsiglist_CFLAGS = $(AM_CFLAGS) $(common_CFLAGS)
-
-sbkeysync_SOURCES = sbkeysync.c $(common_SOURCES)
-sbkeysync_LDADD = $(common_LDADD) $(uuid_LIBS)
-sbkeysync_CPPFLAGS = $(EFI_CPPFLAGS)
-sbkeysync_CFLAGS = $(AM_CFLAGS) $(common_CFLAGS)
+tpmsbsign_SOURCES = tpmsbsign.c $(common_SOURCES)
+tpmsbsign_LDADD = $(common_LDADD)
+tpmsbsign_CFLAGS = $(AM_CFLAGS) $(common_CFLAGS)
+
+tpmkmodsign_SOURCES = tpmkmodsign.c $(common_SOURCES)
+tpmkmodsign_LDADD = $(common_LDADD)
+tpmkmodsign_CFLAGS = $(AM_CFLAGS) $(common_CFLAGS)
--- tpmsbsigntool-0.9.4.orig/src/sbattach.c
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- * Copyright (C) 2012 Jeremy Kerr <jeremy.kerr@canonical.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 3
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
- * USA.
- *
- * In addition, as a special exception, the copyright holders give
- * permission to link the code of portions of this program with the OpenSSL
- * library under certain conditions as described in each individual source file,
- * and distribute linked combinations including the two.
- *
- * You must obey the GNU General Public License in all respects for all
- * of the code used other than OpenSSL. If you modify file(s) with this
- * exception, you may extend this exception to your version of the
- * file(s), but you are not obligated to do so. If you do not wish to do
- * so, delete this exception statement from your version. If you delete
- * this exception statement from all source files in the program, then
- * also delete it here.
- */
-#define _GNU_SOURCE
-
-#include <errno.h>
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <string.h>
-
-#include <getopt.h>
-
-#include <openssl/conf.h>
-#include <openssl/pkcs7.h>
-#include <openssl/evp.h>
-#include <openssl/err.h>
-
-#include <ccan/talloc/talloc.h>
-#include <ccan/read_write_all/read_write_all.h>
-
-#include "config.h"
-
-#include "image.h"
-#include "fileio.h"
-
-static const char *toolname = "sbattach";
-
-static struct option options[] = {
-	{ "attach", required_argument, NULL, 'a' },
-	{ "detach", required_argument, NULL, 'd' },
-	{ "remove", no_argument, NULL, 'r' },
-	{ "help", no_argument, NULL, 'h' },
-	{ "version", no_argument, NULL, 'V' },
-	{ "signum", required_argument, NULL, 's' },
-	{ NULL, 0, NULL, 0 },
-};
-
-static void usage(void)
-{
-	printf("Usage: %s --attach <sigfile> <efi-boot-image>\n"
-		"   or: %s --detach <sigfile> [--remove] <efi-boot-image>\n"
-		"   or: %s --remove <efi-boot-image>\n"
-		"Attach or detach a signature file to/from a boot image\n"
-		"\n"
-		"Options:\n"
-		"\t--attach <sigfile>  set <sigfile> as the boot image's\n"
-		"\t                     signature table\n"
-		"\t--detach <sigfile>  copy the boot image's signature table\n"
-		"\t                     to <sigfile>\n"
-		"\t--remove            remove the boot image's signature\n"
-		"\t                     table from the original file\n"
-	        "\t--signum            signature to operate on (defaults to\n"
-	        "\t                     first)\n",
-		toolname, toolname, toolname);
-}
-
-static void version(void)
-{
-	printf("%s %s\n", toolname, VERSION);
-}
-
-static int detach_sig(struct image *image, int signum, const char *sig_filename)
-{
-	return image_write_detached(image, signum, sig_filename);
-}
-
-static int attach_sig(struct image *image, const char *image_filename,
-		const char *sig_filename)
-{
-	const uint8_t *tmp_buf;
-	uint8_t *sigbuf;
-	size_t size;
-	PKCS7 *p7;
-	int rc;
-
-	rc = fileio_read_file(image, sig_filename, &sigbuf, &size);
-	if (rc)
-		goto out;
-
-	image_add_signature(image, sigbuf, size);
-
-	rc = -1;
-	tmp_buf = sigbuf;
-	p7 = d2i_PKCS7(NULL, &tmp_buf, size);
-	if (!p7) {
-		fprintf(stderr, "Unable to parse signature data in file: %s\n",
-				sig_filename);
-		ERR_print_errors_fp(stderr);
-		goto out;
-	}
-	rc = PKCS7_verify(p7, NULL, NULL, NULL, NULL,
-				PKCS7_BINARY | PKCS7_NOVERIFY | PKCS7_NOSIGS);
-	if (!rc) {
-		fprintf(stderr, "PKCS7 verification failed for file %s\n",
-				sig_filename);
-		ERR_print_errors_fp(stderr);
-		goto out;
-	}
-
-	rc = image_write(image, image_filename);
-	if (rc)
-		fprintf(stderr, "Error writing %s: %s\n", image_filename,
-				strerror(errno));
-
-out:
-	talloc_free(sigbuf);
-	return rc;
-}
-
-static int remove_sig(struct image *image, int signum,
-		      const char *image_filename)
-{
-	int rc;
-
-	rc = image_remove_signature(image, signum);
-
-	if (rc) {
-		fprintf(stderr, "Error, image has no signature at %d\n",
-			signum + 1);
-		return rc;
-	}
-
-	rc = image_write(image, image_filename);
-	if (rc)
-		fprintf(stderr, "Error writing %s: %s\n", image_filename,
-				strerror(errno));
-
-	return rc;
-}
-
-enum action {
-	ACTION_NONE,
-	ACTION_ATTACH,
-	ACTION_DETACH,
-};
-
-int main(int argc, char **argv)
-{
-	const char *image_filename, *sig_filename;
-	struct image *image;
-	enum action action;
-	bool remove;
-	int c, rc, signum = 0;
-
-	action = ACTION_NONE;
-	sig_filename = NULL;
-	remove = false;
-
-	for (;;) {
-		int idx;
-		c = getopt_long(argc, argv, "a:d:s:rhV", options, &idx);
-		if (c == -1)
-			break;
-
-		switch (c) {
-		case 'a':
-		case 'd':
-			if (action != ACTION_NONE) {
-				fprintf(stderr, "Multiple actions specified\n");
-				usage();
-				return EXIT_FAILURE;
-			}
-			action = (c == 'a') ? ACTION_ATTACH : ACTION_DETACH;
-			sig_filename = optarg;
-			break;
-		case 's':
-			/* humans count from 1 not zero */
-			signum = atoi(optarg) - 1;
-			break;
-		case 'r':
-			remove = true;
-			break;
-		case 'V':
-			version();
-			return EXIT_SUCCESS;
-		case 'h':
-			usage();
-			return EXIT_SUCCESS;
-		}
-	}
-
-	if (argc != optind + 1) {
-		usage();
-		return EXIT_FAILURE;
-	}
-	image_filename = argv[optind];
-
-	/* sanity check action combinations */
-	if (action == ACTION_ATTACH && remove) {
-		fprintf(stderr, "Can't use --remove with --attach\n");
-		return EXIT_FAILURE;
-	}
-
-	if (action == ACTION_NONE && !remove) {
-		fprintf(stderr, "No action (attach/detach/remove) specified\n");
-		usage();
-		return EXIT_FAILURE;
-	}
-
-	ERR_load_crypto_strings();
-	OpenSSL_add_all_digests();
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
-	OPENSSL_config(NULL);
-#else
-	OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, NULL);
-#endif
-	/* here we may get highly unlikely failures or we'll get a
-	 * complaint about FIPS signatures (usually becuase the FIPS
-	 * module isn't present).  In either case ignore the errors
-	 * (malloc will cause other failures out lower down */
-	ERR_clear_error();
-
-	image = image_load(image_filename);
-	if (!image) {
-		fprintf(stderr, "Can't load image file %s\n", image_filename);
-		return EXIT_FAILURE;
-	}
-
-	rc = 0;
-
-	if (action == ACTION_ATTACH)
-		rc = attach_sig(image, image_filename, sig_filename);
-
-	else if (action == ACTION_DETACH)
-		rc = detach_sig(image, signum, sig_filename);
-
-	if (rc)
-		goto out;
-
-	if (remove)
-		rc = remove_sig(image, signum, image_filename);
-
-out:
-	talloc_free(image);
-	return (rc == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
-}
--- tpmsbsigntool-0.9.4.orig/src/sbkeysync.c
+++ /dev/null
@@ -1,994 +0,0 @@
-/*
- * Copyright (C) 2012 Jeremy Kerr <jeremy.kerr@canonical.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 3
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
- * USA.
- *
- * In addition, as a special exception, the copyright holders give
- * permission to link the code of portions of this program with the OpenSSL
- * library under certain conditions as described in each individual source file,
- * and distribute linked combinations including the two.
- *
- * You must obey the GNU General Public License in all respects for all
- * of the code used other than OpenSSL. If you modify file(s) with this
- * exception, you may extend this exception to your version of the
- * file(s), but you are not obligated to do so. If you do not wish to do
- * so, delete this exception statement from your version. If you delete
- * this exception statement from all source files in the program, then
- * also delete it here.
- */
-#define _GNU_SOURCE
-
-#include <stdint.h>
-#include <stdlib.h>
-#include <string.h>
-#include <dirent.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <sys/statfs.h>
-#include <sys/types.h>
-
-#include <getopt.h>
-
-#include <ccan/list/list.h>
-#include <ccan/array_size/array_size.h>
-#include <ccan/talloc/talloc.h>
-
-#include <openssl/conf.h>
-#include <openssl/x509.h>
-#include <openssl/err.h>
-
-#include "fileio.h"
-#include "efivars.h"
-
-static struct statfs statfstype;
-
-#define EFIVARS_MOUNTPOINT	"/sys/firmware/efi/efivars"
-#define PSTORE_FSTYPE		((typeof(statfstype.f_type))0x6165676C)
-#define EFIVARS_FSTYPE		((typeof(statfstype.f_type))0xde5e81e4)
-
-#define EFI_IMAGE_SECURITY_DATABASE_GUID \
-	{ 0xd719b2cb, 0x3d3a, 0x4596, \
-	{ 0xa3, 0xbc, 0xda, 0xd0, 0x0e, 0x67, 0x65, 0x6f } }
-
-static const char *toolname = "sbkeysync";
-
-static const uint32_t sigdb_attrs = EFI_VARIABLE_NON_VOLATILE |
-	EFI_VARIABLE_BOOTSERVICE_ACCESS |
-	EFI_VARIABLE_RUNTIME_ACCESS |
-	EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS |
-	EFI_VARIABLE_APPEND_WRITE;
-
-struct key_database_type {
-	const char	*name;
-	EFI_GUID	guid;
-};
-
-struct key_database_type keydb_types[] = {
-	{ "PK",  EFI_GLOBAL_VARIABLE },
-	{ "KEK", EFI_GLOBAL_VARIABLE },
-	{ "db",  EFI_IMAGE_SECURITY_DATABASE_GUID },
-	{ "dbx", EFI_IMAGE_SECURITY_DATABASE_GUID },
-};
-
-enum keydb_type {
-	KEYDB_PK = 0,
-	KEYDB_KEK = 1,
-	KEYDB_DB = 2,
-	KEYDB_DBX = 3,
-};
-
-static const char *default_keystore_dirs[] = {
-	"/etc/secureboot/keys",
-	"/usr/share/secureboot/keys",
-};
-
-
-struct key {
-	EFI_GUID			type;
-	int				id_len;
-	uint8_t				*id;
-
-	char				*description;
-
-	struct list_node		list;
-
-	/* set for keys loaded from a filesystem keystore */
-	struct fs_keystore_entry	*keystore_entry;
-};
-
-typedef int (*key_parse_func)(struct key *, uint8_t *, size_t);
-
-struct cert_type {
-	EFI_GUID	guid;
-	key_parse_func	parse;
-};
-
-struct key_database {
-	const struct key_database_type	*type;
-	struct list_head		keys;
-};
-
-struct keyset {
-	struct key_database	pk;
-	struct key_database	kek;
-	struct key_database	db;
-	struct key_database	dbx;
-};
-
-struct fs_keystore_entry {
-	const struct key_database_type	*type;
-	const char			*root;
-	const char			*name;
-	uint8_t				*data;
-	size_t				len;
-	struct list_node		keystore_list;
-	struct list_node		new_list;
-};
-
-struct fs_keystore {
-	struct list_head	keys;
-};
-
-struct sync_context {
-	const char		*efivars_dir;
-	struct keyset		*filesystem_keys;
-	struct keyset		*firmware_keys;
-	struct fs_keystore	*fs_keystore;
-	const char		**keystore_dirs;
-	unsigned int		n_keystore_dirs;
-	struct list_head	new_keys;
-	bool			verbose;
-	bool			dry_run;
-	bool			set_pk;
-};
-
-
-#define GUID_STRLEN (8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1)
-static void guid_to_str(const EFI_GUID *guid, char *str)
-{
-	snprintf(str, GUID_STRLEN,
-		"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
-			guid->Data1, guid->Data2, guid->Data3,
-			guid->Data4[0], guid->Data4[1],
-			guid->Data4[2], guid->Data4[3],
-			guid->Data4[4], guid->Data4[5],
-			guid->Data4[6], guid->Data4[7]);
-}
-
-static int sha256_key_parse(struct key *key, uint8_t *data, size_t len)
-{
-	const unsigned int sha256_id_size = 256 / 8;
-	unsigned int i;
-
-	if (len != sha256_id_size)
-		return -1;
-
-	key->id = talloc_memdup(key, data, sha256_id_size);
-	key->id_len = sha256_id_size;
-
-	key->description = talloc_array(key, char, len * 2 + 1);
-	for (i = 0; i < len; i++)
-		snprintf(&key->description[i*2], 3, "%02x", data[i]);
-	key->description[len*2] = '\0';
-
-	return 0;
-}
-
-static int x509_key_parse(struct key *key, uint8_t *data, size_t len)
-{
-	const int description_len = 160;
-	ASN1_INTEGER *serial;
-	const uint8_t *tmp;
-	X509 *x509;
-	int rc;
-
-	rc = -1;
-
-	tmp = data;
-
-	x509 = d2i_X509(NULL, &tmp, len);
-	if (!x509)
-		return -1;
-
-	/* we use the X509 serial number as the key ID */
-	serial = X509_get_serialNumber(x509);
-	if (!serial)
-		goto out;
-
-	key->id_len = ASN1_STRING_length(serial);
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
-	key->id = talloc_memdup(key, ASN1_STRING_data(serial), key->id_len);
-#else
-	key->id = talloc_memdup(key, ASN1_STRING_get0_data(serial), key->id_len);
-#endif
-
-	key->description = talloc_array(key, char, description_len);
-	X509_NAME_oneline(X509_get_subject_name(x509),
-			key->description, description_len);
-
-	rc = 0;
-
-out:
-	X509_free(x509);
-	return rc;
-}
-
-struct cert_type cert_types[] = {
-	{ EFI_CERT_SHA256_GUID, sha256_key_parse },
-	{ EFI_CERT_X509_GUID, x509_key_parse },
-};
-
-static int guidcmp(const EFI_GUID *a, const EFI_GUID *b)
-{
-	return memcmp(a, b, sizeof(EFI_GUID));
-}
-
-static int key_parse(struct key *key, const EFI_GUID *type,
-		uint8_t *data, size_t len)
-{
-	char guid_str[GUID_STRLEN];
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(cert_types); i++) {
-		if (guidcmp(&cert_types[i].guid, type))
-			continue;
-
-		return cert_types[i].parse(key, data, len);
-	}
-
-	guid_to_str(type, guid_str);
-	printf("warning: unknown signature type found:\n  %s\n",
-			guid_str);
-	return -1;
-
-}
-
-typedef int (*sigdata_fn)(EFI_SIGNATURE_DATA *, int, const EFI_GUID *, void *);
-
-/**
- * Iterates an buffer of EFI_SIGNATURE_LISTs (at db_data, of length len),
- * and calls fn on each EFI_SIGNATURE_DATA item found.
- *
- * fn is passed the EFI_SIGNATURE_DATA pointer, and the length of the
- * signature data (including GUID header), the type of the signature list,
- * and a context pointer.
- */
-static int sigdb_iterate(void *db_data, size_t len,
-		sigdata_fn fn, void *arg)
-{
-	EFI_SIGNATURE_LIST *siglist;
-	EFI_SIGNATURE_DATA *sigdata;
-	unsigned int i, j;
-	int rc = 0;
-
-	if (len == 0)
-		return 0;
-
-	if (len < sizeof(*siglist))
-		return -1;
-
-	for (i = 0, siglist = db_data + i;
-			i + sizeof(*siglist) <= len &&
-			i + siglist->SignatureListSize > i &&
-			i + siglist->SignatureListSize <= len && !rc;
-			i += siglist->SignatureListSize,
-			siglist = db_data + i) {
-
-		/* ensure that the header & sig sizes are sensible */
-		if (siglist->SignatureHeaderSize > siglist->SignatureListSize)
-			continue;
-
-		if (siglist->SignatureSize > siglist->SignatureListSize)
-			continue;
-
-		if (siglist->SignatureSize < sizeof(*sigdata))
-			continue;
-
-		/* iterate through the (constant-sized) signature data blocks */
-		for (j = sizeof(*siglist) + siglist->SignatureHeaderSize;
-				j < siglist->SignatureListSize && !rc;
-				j += siglist->SignatureSize)
-		{
-			sigdata = (void *)(siglist) + j;
-
-			rc = fn(sigdata, siglist->SignatureSize,
-					&siglist->SignatureType, arg);
-
-		}
-
-	}
-
-	return rc;
-}
-
-struct keydb_add_ctx {
-	struct fs_keystore_entry *ke;
-	struct key_database *kdb;
-	struct keyset *keyset;
-};
-
-static int keydb_add_key(EFI_SIGNATURE_DATA *sigdata, int len,
-		const EFI_GUID *type, void *arg)
-{
-	struct keydb_add_ctx *add_ctx = arg;
-	struct key *key;
-	int rc;
-
-	key = talloc(add_ctx->keyset, struct key);
-
-	rc = key_parse(key, type, sigdata->SignatureData,
-			len - sizeof(*sigdata));
-
-	if (rc) {
-		talloc_free(key);
-		return 0;
-	}
-	key->keystore_entry = add_ctx->ke;
-	key->type = *type;
-
-	/* add a reference to the keystore entry: we don't want it to be
-	 * deallocated if the keystore is deallocated before the
-	 * struct key. */
-	if (key->keystore_entry)
-		talloc_reference(key, key->keystore_entry);
-
-	list_add(&add_ctx->kdb->keys, &key->list);
-
-	return 0;
-}
-
-static int read_firmware_keydb(struct sync_context *ctx,
-		struct key_database *kdb)
-{
-	struct keydb_add_ctx add_ctx;
-	char guid_str[GUID_STRLEN];
-	char *filename;
-	uint8_t *buf;
-	int rc = -1;
-	size_t len;
-
-	add_ctx.keyset = ctx->firmware_keys;
-	add_ctx.kdb = kdb;
-	add_ctx.ke = NULL;
-
-	guid_to_str(&kdb->type->guid, guid_str);
-
-	filename = talloc_asprintf(ctx->firmware_keys, "%s/%s-%s",
-			ctx->efivars_dir, kdb->type->name, guid_str);
-
-	buf = NULL;
-	rc = fileio_read_file_noerror(ctx->firmware_keys, filename, &buf, &len);
-	if (rc)
-		goto out;
-
-	/* efivars files start with a 32-bit attribute block */
-	if (len < sizeof(uint32_t))
-		goto out;
-
-	buf += sizeof(uint32_t);
-	len -= sizeof(uint32_t);
-
-	rc = 0;
-	sigdb_iterate(buf, len, keydb_add_key, &add_ctx);
-
-out:
-	if (rc)
-		talloc_free(buf);
-	talloc_free(filename);
-
-	return rc;
-}
-
-static void __attribute__((format(printf, 2, 3))) print_keystore_key_error(
-		struct fs_keystore_entry *ke, const char *fmt, ...)
-{
-	char *errstr;
-	va_list ap;
-
-	va_start(ap, fmt);
-	errstr = talloc_vasprintf(ke, fmt, ap);
-
-	fprintf(stderr, "Invalid key %s/%s\n - %s\n", ke->root, ke->name,
-			errstr);
-
-	talloc_free(errstr);
-	va_end(ap);
-}
-
-static int read_filesystem_keydb(struct sync_context *ctx,
-		struct key_database *kdb)
-{
-	EFI_GUID cert_type_pkcs7 = EFI_CERT_TYPE_PKCS7_GUID;
-	EFI_VARIABLE_AUTHENTICATION_2 *auth;
-	struct keydb_add_ctx add_ctx;
-	struct fs_keystore_entry *ke;
-	int rc;
-
-	add_ctx.keyset = ctx->filesystem_keys;
-	add_ctx.kdb = kdb;
-
-	list_for_each(&ctx->fs_keystore->keys, ke, keystore_list) {
-		unsigned int len;
-		void *buf;
-
-		if (ke->len == 0)
-			continue;
-
-		if (ke->type != kdb->type)
-			continue;
-
-		/* parse the three data structures:
-		 *  EFI_VARIABLE_AUTHENTICATION_2 token
-		 *  EFI_SIGNATURE_LIST
-		 *  EFI_SIGNATURE_DATA
-		 * ensuring that we have enough data for each
-		 */
-
-		buf = ke->data;
-		len = ke->len;
-
-		if (len < sizeof(*auth)) {
-			print_keystore_key_error(ke, "does not contain an "
-				"EFI_VARIABLE_AUTHENTICATION_2 descriptor");
-			continue;
-		}
-
-		auth = buf;
-
-		if (guidcmp(&auth->AuthInfo.CertType, &cert_type_pkcs7)) {
-			print_keystore_key_error(ke, "unknown cert type");
-			continue;
-		}
-
-		if (auth->AuthInfo.Hdr.dwLength > len) {
-			print_keystore_key_error(ke,
-					"invalid WIN_CERTIFICATE length");
-			continue;
-		}
-
-		/* the dwLength field includes the size of the WIN_CERTIFICATE,
-		 * but not the other data in the EFI_VARIABLE_AUTHENTICATION_2
-		 * descriptor */
-		buf += sizeof(*auth) - sizeof(auth->AuthInfo) +
-			auth->AuthInfo.Hdr.dwLength;
-		len -= sizeof(*auth) - sizeof(auth->AuthInfo) +
-			auth->AuthInfo.Hdr.dwLength;
-
-		add_ctx.ke = ke;
-		rc = sigdb_iterate(buf, len, keydb_add_key, &add_ctx);
-		if (rc) {
-			print_keystore_key_error(ke, "error parsing "
-					"EFI_SIGNATURE_LIST");
-			continue;
-		}
-
-	}
-
-	return 0;
-}
-
-static int read_keysets(struct sync_context *ctx)
-{
-	read_firmware_keydb(ctx, &ctx->firmware_keys->pk);
-	read_firmware_keydb(ctx, &ctx->firmware_keys->kek);
-	read_firmware_keydb(ctx, &ctx->firmware_keys->db);
-	read_firmware_keydb(ctx, &ctx->firmware_keys->dbx);
-
-	read_filesystem_keydb(ctx, &ctx->filesystem_keys->pk);
-	read_filesystem_keydb(ctx, &ctx->filesystem_keys->kek);
-	read_filesystem_keydb(ctx, &ctx->filesystem_keys->db);
-	read_filesystem_keydb(ctx, &ctx->filesystem_keys->dbx);
-
-	return 0;
-}
-
-static int check_pk(struct sync_context *ctx)
-{
-	struct key *key;
-	int i = 0;
-
-	list_for_each(&ctx->filesystem_keys->pk.keys, key, list)
-		i++;
-
-	return (i <= 1) ? 0 : 1;
-}
-
-static void print_keyset(struct keyset *keyset, const char *name)
-{
-	struct key_database *kdbs[] =
-		{ &keyset->pk, &keyset->kek, &keyset->db, &keyset->dbx };
-	struct key *key;
-	unsigned int i;
-
-	printf("%s keys:\n", name);
-
-	for (i = 0; i < ARRAY_SIZE(kdbs); i++) {
-		printf("  %s:\n", kdbs[i]->type->name);
-
-		list_for_each(&kdbs[i]->keys, key, list) {
-			printf("    %s\n", key->description);
-			if (key->keystore_entry)
-				printf("     from %s/%s\n",
-						key->keystore_entry->root,
-						key->keystore_entry->name);
-		}
-	}
-}
-
-static int check_efivars_mount(const char *mountpoint)
-{
-	struct statfs statbuf;
-	int rc;
-
-	rc = statfs(mountpoint, &statbuf);
-	if (rc)
-		return -1;
-
-	if (statbuf.f_type != EFIVARS_FSTYPE && statbuf.f_type != PSTORE_FSTYPE)
-		return -1;
-
-	return 0;
-}
-
-static int keystore_entry_read(struct fs_keystore_entry *ke)
-{
-	const char *path;
-	int rc;
-
-	path = talloc_asprintf(ke, "%s/%s", ke->root, ke->name);
-
-	rc = fileio_read_file(ke, path, &ke->data, &ke->len);
-
-	talloc_free(path);
-
-	return rc;
-}
-
-static bool keystore_contains_file(struct fs_keystore *keystore,
-		const char *filename)
-{
-	struct fs_keystore_entry *ke;
-
-	list_for_each(&keystore->keys, ke, keystore_list) {
-		if (!strcmp(ke->name, filename))
-			return true;
-	}
-
-	return false;
-}
-
-static int update_keystore(struct fs_keystore *keystore, const char *root)
-{
-	struct fs_keystore_entry *ke;
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(keydb_types); i++) {
-		const char *filename, *dirname;
-		struct dirent *dirent;
-		DIR *dir;
-
-		dirname = talloc_asprintf(keystore, "%s/%s", root,
-					keydb_types[i].name);
-
-		dir = opendir(dirname);
-		if (!dir)
-			continue;
-
-		for (dirent = readdir(dir); dirent; dirent = readdir(dir)) {
-
-			if (dirent->d_name[0] == '.')
-				continue;
-
-			filename = talloc_asprintf(dirname, "%s/%s",
-					keydb_types[i].name,
-					dirent->d_name);
-
-			if (keystore_contains_file(keystore, filename))
-				continue;
-
-			ke = talloc(keystore, struct fs_keystore_entry);
-			ke->name = filename;
-			ke->root = root;
-			ke->type = &keydb_types[i];
-			talloc_steal(ke, ke->name);
-
-			if (keystore_entry_read(ke))
-				talloc_free(ke);
-			else
-				list_add(&keystore->keys, &ke->keystore_list);
-		}
-
-		closedir(dir);
-		talloc_free(dirname);
-	}
-
-	return 0;
-}
-
-static int read_keystore(struct sync_context *ctx)
-{
-	struct fs_keystore *keystore;
-	unsigned int i;
-
-	keystore = talloc(ctx, struct fs_keystore);
-	list_head_init(&keystore->keys);
-
-	for (i = 0; i < ctx->n_keystore_dirs; i++) {
-		update_keystore(keystore, ctx->keystore_dirs[i]);
-	}
-
-	ctx->fs_keystore = keystore;
-
-	return 0;
-}
-
-static void print_keystore(struct fs_keystore *keystore)
-{
-	struct fs_keystore_entry *ke;
-
-	printf("Filesystem keystore:\n");
-
-	list_for_each(&keystore->keys, ke, keystore_list)
-		printf("  %s/%s [%zd bytes]\n", ke->root, ke->name, ke->len);
-}
-
-static int key_cmp(struct key *a, struct key *b)
-{
-	if (a->id_len != b->id_len)
-		return a->id_len - b->id_len;
-
-	return memcmp(a->id, b->id, a->id_len);
-}
-
-/**
- * Finds the set-difference of the filesystem and firmware keys, and
- * populates ctx->new_keys with the keystore_entries that should be
- * inserted into firmware
- */
-static int find_new_keys(struct sync_context *ctx)
-{
-	struct {
-		struct key_database *fs_kdb, *fw_kdb;
-	} kdbs[] = {
-		{ &ctx->filesystem_keys->pk,  &ctx->firmware_keys->pk },
-		{ &ctx->filesystem_keys->kek, &ctx->firmware_keys->kek },
-		{ &ctx->filesystem_keys->db,  &ctx->firmware_keys->db },
-		{ &ctx->filesystem_keys->dbx, &ctx->firmware_keys->dbx },
-	};
-	unsigned int i;
-	int n = 0;
-
-	for (i = 0; i < ARRAY_SIZE(kdbs); i++ ) {
-		struct fs_keystore_entry *ke;
-		struct key *fs_key, *fw_key;
-		bool found;
-
-		list_for_each(&kdbs[i].fs_kdb->keys, fs_key, list) {
-			found = false;
-			list_for_each(&kdbs[i].fw_kdb->keys, fw_key, list) {
-				if (!key_cmp(fs_key, fw_key)) {
-					found = true;
-					break;
-				}
-			}
-			if (found)
-				continue;
-
-			/* add the keystore entry if it's not already present */
-			found = false;
-			list_for_each(&ctx->new_keys, ke, new_list) {
-				if (fs_key->keystore_entry == ke) {
-					found = true;
-					break;
-				}
-			}
-
-			if (found)
-				continue;
-
-			list_add(&ctx->new_keys,
-					&fs_key->keystore_entry->new_list);
-			n++;
-		}
-	}
-
-	return n;
-}
-
-static void print_new_keys(struct sync_context *ctx)
-{
-	struct fs_keystore_entry *ke;
-
-	printf("New keys in filesystem:\n");
-
-	list_for_each(&ctx->new_keys, ke, new_list)
-		printf(" %s/%s\n", ke->root, ke->name);
-}
-
-static int insert_key(struct sync_context *ctx, struct fs_keystore_entry *ke)
-{
-	char guid_str[GUID_STRLEN];
-	char *efivars_filename;
-	unsigned int buf_len;
-	uint8_t *buf;
-	int fd, rc;
-
-	fd = -1;
-	rc = -1;
-
-	if (ctx->verbose)
-		printf("Inserting key update %s/%s into %s\n",
-				ke->root, ke->name, ke->type->name);
-
-	/* we create a contiguous buffer of attributes & key data, so that
-	 * we write to the efivars file in a single syscall */
-	buf_len = sizeof(sigdb_attrs) + ke->len;
-	buf = talloc_array(ke, uint8_t, buf_len);
-	memcpy(buf, &sigdb_attrs, sizeof(sigdb_attrs));
-	memcpy(buf + sizeof(sigdb_attrs), ke->data, ke->len);
-
-	guid_to_str(&ke->type->guid, guid_str);
-
-	efivars_filename = talloc_asprintf(ke, "%s/%s-%s", ctx->efivars_dir,
-						ke->type->name, guid_str);
-
-	fd = open(efivars_filename, O_WRONLY | O_CREAT, 0600);
-	if (fd < 0) {
-		fprintf(stderr,	"Can't create key file %s: %s\n",
-				efivars_filename, strerror(errno));
-		goto out;
-	}
-
-	rc = write(fd, buf, buf_len);
-	if (rc <= 0) {
-		fprintf(stderr, "Error writing key update: %s\n",
-				strerror(errno));
-		goto out;
-	}
-
-	if (rc != (int)buf_len) {
-		fprintf(stderr, "Partial write during key update: "
-				"wrote %d bytes, expecting %d\n",
-				rc, buf_len);
-		goto out;
-	}
-
-	rc = 0;
-
-out:
-	if (fd >= 0)
-		close(fd);
-	talloc_free(efivars_filename);
-	talloc_free(buf);
-	if (rc)
-		fprintf(stderr, "Error syncing keystore file %s/%s\n",
-				ke->root, ke->name);
-	return rc;
-}
-
-static int insert_new_keys(struct sync_context *ctx)
-{
-	struct fs_keystore_entry *ke, *ke_pk;
-	int pks, rc;
-
-	rc = 0;
-	pks = 0;
-	ke_pk = NULL;
-
-	list_for_each(&ctx->new_keys, ke, new_list) {
-
-		/* we handle PK last */
-		if (ke->type == &keydb_types[KEYDB_PK]) {
-			ke_pk = ke;
-			pks++;
-			continue;
-		}
-
-		if (insert_key(ctx, ke))
-			rc = -1;
-	}
-
-	if (rc)
-		return rc;
-
-	if (pks == 0 || !ctx->set_pk)
-		return 0;
-
-	if (pks > 1) {
-		fprintf(stderr, "Skipping PK update due to mutiple PKs\n");
-		return -1;
-	}
-
-	rc = insert_key(ctx, ke_pk);
-
-	return rc;
-}
-
-static struct keyset *init_keyset(struct sync_context *ctx)
-{
-	struct keyset *keyset;
-
-	keyset = talloc(ctx, struct keyset);
-
-	list_head_init(&keyset->pk.keys);
-	keyset->pk.type = &keydb_types[KEYDB_PK];
-
-	list_head_init(&keyset->kek.keys);
-	keyset->kek.type = &keydb_types[KEYDB_KEK];
-
-	list_head_init(&keyset->db.keys);
-	keyset->db.type = &keydb_types[KEYDB_DB];
-
-	list_head_init(&keyset->dbx.keys);
-	keyset->dbx.type = &keydb_types[KEYDB_DBX];
-
-	return keyset;
-}
-
-static struct option options[] = {
-	{ "help", no_argument, NULL, 'h' },
-	{ "version", no_argument, NULL, 'V' },
-	{ "efivars-path", required_argument, NULL, 'e' },
-	{ "verbose", no_argument, NULL, 'v' },
-	{ "dry-run", no_argument, NULL, 'n' },
-	{ "pk", no_argument, NULL, 'p' },
-	{ "no-default-keystores", no_argument, NULL, 'd' },
-	{ "keystore", required_argument, NULL, 'k' },
-	{ NULL, 0, NULL, 0 },
-};
-
-static void usage(void)
-{
-	printf("Usage: %s [options]\n"
-		"Update EFI key databases from the filesystem\n"
-		"\n"
-		"Options:\n"
-		"\t--efivars-path <dir>  Path to efivars mountpoint\n"
-		"\t                       (or regular directory for testing)\n"
-		"\t--verbose             Print verbose progress information\n"
-		"\t--dry-run             Don't update firmware key databases\n"
-		"\t--pk                  Set PK\n"
-		"\t--keystore <dir>      Read keys from <dir>/{db,dbx,KEK}/*\n"
-		"\t                       (can be specified multiple times,\n"
-		"\t                       first dir takes precedence)\n"
-		"\t--no-default-keystores\n"
-		"\t                      Don't read keys from the default\n"
-		"\t                       keystore dirs\n",
-		toolname);
-}
-
-static void version(void)
-{
-	printf("%s %s\n", toolname, VERSION);
-}
-
-static void add_keystore_dir(struct sync_context *ctx, const char *dir)
-{
-	ctx->keystore_dirs = talloc_realloc(ctx, ctx->keystore_dirs,
-			const char *, ++ctx->n_keystore_dirs);
-
-	ctx->keystore_dirs[ctx->n_keystore_dirs - 1] =
-				talloc_strdup(ctx->keystore_dirs, dir);
-}
-
-int main(int argc, char **argv)
-{
-	bool use_default_keystore_dirs;
-	struct sync_context *ctx;
-
-	use_default_keystore_dirs = true;
-	ctx = talloc_zero(NULL, struct sync_context);
-	list_head_init(&ctx->new_keys);
-
-	for (;;) {
-		int idx, c;
-		c = getopt_long(argc, argv, "e:dpkvhV", options, &idx);
-		if (c == -1)
-			break;
-
-		switch (c) {
-		case 'e':
-			ctx->efivars_dir = optarg;
-			break;
-		case 'd':
-			use_default_keystore_dirs = false;
-			break;
-		case 'k':
-			add_keystore_dir(ctx, optarg);
-			break;
-		case 'p':
-			ctx->set_pk = true;
-			break;
-		case 'v':
-			ctx->verbose = true;
-			break;
-		case 'n':
-			ctx->dry_run = true;
-			break;
-		case 'V':
-			version();
-			return EXIT_SUCCESS;
-		case 'h':
-			usage();
-			return EXIT_SUCCESS;
-		}
-	}
-
-	if (argc != optind) {
-		usage();
-		return EXIT_FAILURE;
-	}
-
-	ERR_load_crypto_strings();
-	OpenSSL_add_all_digests();
-	OpenSSL_add_all_ciphers();
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
-	OPENSSL_config(NULL);
-#else
-	OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, NULL);
-#endif
-	/* here we may get highly unlikely failures or we'll get a
-	 * complaint about FIPS signatures (usually becuase the FIPS
-	 * module isn't present).  In either case ignore the errors
-	 * (malloc will cause other failures out lower down */
-	ERR_clear_error();
-
-	ctx->filesystem_keys = init_keyset(ctx);
-	ctx->firmware_keys = init_keyset(ctx);
-
-	if (!ctx->efivars_dir) {
-		ctx->efivars_dir = EFIVARS_MOUNTPOINT;
-		if (check_efivars_mount(ctx->efivars_dir)) {
-			fprintf(stderr, "Can't access efivars filesystem "
-					"at %s, aborting\n", ctx->efivars_dir);
-			return EXIT_FAILURE;
-		}
-	}
-
-	if (use_default_keystore_dirs) {
-		unsigned int i;
-		for (i = 0; i < ARRAY_SIZE(default_keystore_dirs); i++)
-			add_keystore_dir(ctx, default_keystore_dirs[i]);
-	}
-
-
-	read_keystore(ctx);
-
-	if (ctx->verbose)
-		print_keystore(ctx->fs_keystore);
-
-	read_keysets(ctx);
-	if (ctx->verbose) {
-		print_keyset(ctx->firmware_keys, "firmware");
-		print_keyset(ctx->filesystem_keys, "filesystem");
-	}
-
-	if (check_pk(ctx))
-		fprintf(stderr, "WARNING: multiple PKs found in filesystem\n");
-
-	find_new_keys(ctx);
-
-	if (ctx->verbose)
-		print_new_keys(ctx);
-
-	if (!ctx->dry_run)
-		insert_new_keys(ctx);
-
-	talloc_free(ctx);
-
-	return EXIT_SUCCESS;
-}
--- tpmsbsigntool-0.9.4.orig/src/sbsiglist.c
+++ /dev/null
@@ -1,280 +0,0 @@
-/*
- * Copyright (C) 2012 Jeremy Kerr <jeremy.kerr@canonical.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 3
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
- * USA.
- *
- * In addition, as a special exception, the copyright holders give
- * permission to link the code of portions of this program with the OpenSSL
- * library under certain conditions as described in each individual source file,
- * and distribute linked combinations including the two.
- *
- * You must obey the GNU General Public License in all respects for all
- * of the code used other than OpenSSL. If you modify file(s) with this
- * exception, you may extend this exception to your version of the
- * file(s), but you are not obligated to do so. If you do not wish to do
- * so, delete this exception statement from your version. If you delete
- * this exception statement from all source files in the program, then
- * also delete it here.
- */
-#define _GNU_SOURCE
-
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <getopt.h>
-
-#include <uuid/uuid.h>
-
-#include <openssl/bio.h>
-#include <openssl/evp.h>
-#include <openssl/err.h>
-#include <openssl/pem.h>
-#include <openssl/pkcs7.h>
-
-#include <ccan/array_size/array_size.h>
-#include <ccan/read_write_all/read_write_all.h>
-#include <ccan/talloc/talloc.h>
-
-#include "efivars.h"
-#include "fileio.h"
-
-static const char *toolname = "sbsiglist";
-
-static struct option options[] = {
-	{ "output", required_argument, NULL, 'o' },
-	{ "type", required_argument, NULL, 't' },
-	{ "owner", required_argument, NULL, 'w' },
-	{ "verbose", no_argument, NULL, 'v' },
-	{ "help", no_argument, NULL, 'h' },
-	{ "version", no_argument, NULL, 'V' },
-	{ NULL, 0, NULL, 0 },
-};
-
-struct cert_type {
-	const char	*name;
-	const EFI_GUID	guid;
-	unsigned int	sigsize;
-};
-
-struct cert_type cert_types[] = {
-	{ "x509",   EFI_CERT_X509_GUID,   0 },
-	{ "sha256", EFI_CERT_SHA256_GUID, 32 },
-};
-
-struct siglist_context {
-	int			verbose;
-
-	const char		*infilename;
-	const char		*outfilename;
-	const struct cert_type	*type;
-	EFI_GUID		owner;
-
-	uint8_t			*data;
-	size_t			data_len;
-
-	EFI_SIGNATURE_LIST	*siglist;
-};
-
-
-void usage(void)
-{
-	unsigned int i;
-
-	printf("Usage: %s [options] --owner <guid> --type <type> <sig-file>\n"
-		"Create an EFI_SIGNATURE_LIST from a signature file\n"
-		"Options:\n"
-		"\t--owner <guid>   Signature owner GUID\n"
-		"\t--type <type>    Signature type. One of:\n",
-		toolname);
-
-	for (i = 0; i < ARRAY_SIZE(cert_types); i++)
-		printf("\t                     %s\n", cert_types[i].name);
-
-	printf("\t--output <file>  write signed data to <file>\n"
-		"\t                  (default <sig-file>.siglist)\n");
-}
-
-static void version(void)
-{
-	printf("%s %s\n", toolname, VERSION);
-}
-
-static int siglist_create(struct siglist_context *ctx)
-{
-	EFI_SIGNATURE_LIST *siglist;
-	EFI_SIGNATURE_DATA *sigdata;
-	uint32_t size;
-
-	if (ctx->type->sigsize && ctx->data_len != ctx->type->sigsize) {
-		fprintf(stderr, "Error: signature lists of type '%s' expect "
-					"%d bytes of data, "
-					"%zd bytes provided.\n",
-				ctx->type->name,
-				ctx->type->sigsize,
-				ctx->data_len);
-		return -1;
-	}
-
-	size = sizeof(*siglist) + sizeof(*sigdata) + ctx->data_len;
-
-	siglist = talloc_size(ctx, size);
-	sigdata = (void *)(siglist + 1);
-
-	siglist->SignatureType = ctx->type->guid;
-	siglist->SignatureListSize = size;
-	siglist->SignatureHeaderSize = 0;
-	siglist->SignatureSize = ctx->data_len + sizeof(*sigdata);
-
-	sigdata->SignatureOwner = ctx->owner;
-
-	memcpy(sigdata->SignatureData, ctx->data, ctx->data_len);
-
-	ctx->siglist = siglist;
-
-	return 0;
-}
-
-static int parse_guid(const char *str, EFI_GUID *guid)
-{
-	uuid_t uuid;
-
-	if (uuid_parse(str, uuid))
-		return -1;
-
-	/* convert to an EFI_GUID */
-	guid->Data1 = uuid[0] << 24 | uuid[1] << 16 | uuid[2] << 8 | uuid[3];
-	guid->Data2 = uuid[4] << 8 | uuid[5];
-	guid->Data3 = uuid[6] << 8 | uuid[7];
-	memcpy(guid->Data4, &uuid[8], sizeof(guid->Data4));
-
-	return 0;
-}
-
-static struct cert_type *parse_type(const char *str)
-{
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(cert_types); i++)
-		if (!strcasecmp(cert_types[i].name, str))
-			return &cert_types[i];
-
-	return NULL;
-}
-
-static void set_default_outfilename(struct siglist_context *ctx)
-{
-	const char *extension = "siglist";
-
-	ctx->outfilename = talloc_asprintf(ctx, "%s.%s",
-			ctx->infilename, extension);
-}
-int main(int argc, char **argv)
-{
-	const char *type_str, *owner_guid_str;
-	struct siglist_context *ctx;
-	int c;
-
-	ctx = talloc_zero(NULL, struct siglist_context);
-
-	owner_guid_str = NULL;
-	type_str = NULL;
-
-	for (;;) {
-		int idx;
-		c = getopt_long(argc, argv, "o:t:w:ivVh", options, &idx);
-		if (c == -1)
-			break;
-
-		switch (c) {
-		case 'o':
-			ctx->outfilename = optarg;
-			break;
-		case 't':
-			type_str = optarg;
-			break;
-		case 'w':
-			owner_guid_str = optarg;
-			break;
-		case 'v':
-			ctx->verbose = 1;
-			break;
-		case 'V':
-			version();
-			return EXIT_SUCCESS;
-		case 'h':
-			usage();
-			return EXIT_SUCCESS;
-		}
-	}
-
-	if (argc != optind + 1) {
-		usage();
-		return EXIT_FAILURE;
-	}
-
-	ctx->infilename = argv[optind];
-
-	if (!type_str) {
-		fprintf(stderr, "No type specified\n");
-		usage();
-		return EXIT_FAILURE;
-	}
-
-	if (!type_str) {
-		fprintf(stderr, "No owner specified\n");
-		usage();
-		return EXIT_FAILURE;
-	}
-
-	ctx->type = parse_type(type_str);
-	if (!ctx->type) {
-		fprintf(stderr, "Invalid type '%s'\n", type_str);
-		return EXIT_FAILURE;
-	}
-
-	if (parse_guid(owner_guid_str, &ctx->owner)) {
-		fprintf(stderr, "Invalid owner GUID '%s'\n", owner_guid_str);
-		return EXIT_FAILURE;
-	}
-
-	if (!ctx->outfilename)
-		set_default_outfilename(ctx);
-
-	if (fileio_read_file(ctx, ctx->infilename,
-				&ctx->data, &ctx->data_len)) {
-		fprintf(stderr, "Can't read input file %s\n", ctx->infilename);
-		return EXIT_FAILURE;
-	}
-
-	if (siglist_create(ctx))
-		return EXIT_FAILURE;
-
-	if (fileio_write_file(ctx->outfilename,
-				(void *)ctx->siglist,
-				ctx->siglist->SignatureListSize)) {
-		fprintf(stderr, "Can't write output file %s\n",
-				ctx->outfilename);
-		return EXIT_FAILURE;
-	}
-
-	return EXIT_SUCCESS;
-}
--- tpmsbsigntool-0.9.4.orig/src/sbsign.c
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
- * Copyright (C) 2012 Jeremy Kerr <jeremy.kerr@canonical.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 3
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
- * USA.
- *
- * In addition, as a special exception, the copyright holders give
- * permission to link the code of portions of this program with the OpenSSL
- * library under certain conditions as described in each individual source file,
- * and distribute linked combinations including the two.
- *
- * You must obey the GNU General Public License in all respects for all
- * of the code used other than OpenSSL. If you modify file(s) with this
- * exception, you may extend this exception to your version of the
- * file(s), but you are not obligated to do so. If you do not wish to do
- * so, delete this exception statement from your version. If you delete
- * this exception statement from all source files in the program, then
- * also delete it here.
- */
-#define _GNU_SOURCE
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <fcntl.h>
-#include <string.h>
-
-#include <getopt.h>
-
-#include <openssl/conf.h>
-#include <openssl/pem.h>
-#include <openssl/pkcs7.h>
-#include <openssl/err.h>
-#include <openssl/evp.h>
-#include <openssl/asn1.h>
-#include <openssl/asn1t.h>
-#include <openssl/bio.h>
-#include <openssl/x509.h>
-
-#include <ccan/talloc/talloc.h>
-
-#include "idc.h"
-#include "image.h"
-#include "fileio.h"
-
-static const char *toolname = "sbsign";
-
-struct sign_context {
-	struct image *image;
-	const char *infilename;
-	const char *outfilename;
-	int verbose;
-	int detached;
-};
-
-static struct option options[] = {
-	{ "output", required_argument, NULL, 'o' },
-	{ "cert", required_argument, NULL, 'c' },
-	{ "key", required_argument, NULL, 'k' },
-	{ "detached", no_argument, NULL, 'd' },
-	{ "verbose", no_argument, NULL, 'v' },
-	{ "help", no_argument, NULL, 'h' },
-	{ "version", no_argument, NULL, 'V' },
-	{ "engine", required_argument, NULL, 'e'},
-	{ "addcert", required_argument, NULL, 'a'},
-	{ NULL, 0, NULL, 0 },
-};
-
-static void usage(void)
-{
-	printf("Usage: %s [options] --key <keyfile> --cert <certfile> "
-			"<efi-boot-image>\n"
-		"Sign an EFI boot image for use with secure boot.\n\n"
-		"Options:\n"
-		"\t--engine <eng>     use the specified engine to load the key\n"
-		"\t--key <keyfile>    signing key (PEM-encoded RSA "
-						"private key)\n"
-		"\t--cert <certfile>  certificate (x509 certificate)\n"
-		"\t--addcert <addcertfile> additional intermediate certificates in a file\n"
-		"\t--detached         write a detached signature, instead of\n"
-		"\t                    a signed binary\n"
-		"\t--output <file>    write signed data to <file>\n"
-		"\t                    (default <efi-boot-image>.signed,\n"
-		"\t                    or <efi-boot-image>.pk7 for detached\n"
-		"\t                    signatures)\n",
-		toolname);
-}
-
-static void version(void)
-{
-	printf("%s %s\n", toolname, VERSION);
-}
-
-static void set_default_outfilename(struct sign_context *ctx)
-{
-	const char *extension;
-
-	extension = ctx->detached ? "pk7" : "signed";
-
-	ctx->outfilename = talloc_asprintf(ctx, "%s.%s",
-			ctx->infilename, extension);
-}
-
-static int add_intermediate_certs(PKCS7 *p7, const char *filename)
-{
-	STACK_OF(X509_INFO) *certs;
-	X509_INFO *cert;
-	BIO *bio = NULL;
-	int i;
-
-	bio = BIO_new(BIO_s_file());
-	if (!bio || BIO_read_filename(bio, filename) <=0) {
-		fprintf(stderr,
-			"error in reading intermediate certificates file\n");
-		ERR_print_errors_fp(stderr);
-		return -1;
-	}
-
-	certs = PEM_X509_INFO_read_bio(bio, NULL, NULL, NULL);
-	if (!certs) {
-		fprintf(stderr,
-			"error in parsing intermediate certificates file\n");
-		ERR_print_errors_fp(stderr);
-		return -1;
-	}
-
-	for (i = 0; i < sk_X509_INFO_num(certs); i++) {
-		cert = sk_X509_INFO_value(certs, i);
-		PKCS7_add_certificate(p7, cert->x509);
-	}
-
-	sk_X509_INFO_pop_free(certs, X509_INFO_free);
-	BIO_free_all(bio);
-
-	return 0;
-}
-
-int main(int argc, char **argv)
-{
-	const char *keyfilename, *certfilename, *addcertfilename, *engine;
-	struct sign_context *ctx;
-	uint8_t *buf, *tmp;
-	int rc, c, sigsize;
-	EVP_PKEY *pkey;
-
-	ctx = talloc_zero(NULL, struct sign_context);
-
-	keyfilename = NULL;
-	certfilename = NULL;
-	addcertfilename = NULL;
-	engine = NULL;
-
-	for (;;) {
-		int idx;
-		c = getopt_long(argc, argv, "o:c:k:dvVhe:a:", options, &idx);
-		if (c == -1)
-			break;
-
-		switch (c) {
-		case 'o':
-			ctx->outfilename = talloc_strdup(ctx, optarg);
-			break;
-		case 'c':
-			certfilename = optarg;
-			break;
-		case 'k':
-			keyfilename = optarg;
-			break;
-		case 'd':
-			ctx->detached = 1;
-			break;
-		case 'v':
-			ctx->verbose = 1;
-			break;
-		case 'V':
-			version();
-			return EXIT_SUCCESS;
-		case 'h':
-			usage();
-			return EXIT_SUCCESS;
-		case 'e':
-			engine = optarg;
-			break;
-		case 'a':
-			addcertfilename = optarg;
-			break;
-		}
-	}
-
-	if (argc != optind + 1) {
-		usage();
-		return EXIT_FAILURE;
-	}
-
-	ctx->infilename = argv[optind];
-	if (!ctx->outfilename)
-		set_default_outfilename(ctx);
-
-	if (!certfilename) {
-		fprintf(stderr,
-			"error: No certificate specified (with --cert)\n");
-		usage();
-		return EXIT_FAILURE;
-	}
-	if (!keyfilename) {
-		fprintf(stderr,
-			"error: No key specified (with --key)\n");
-		usage();
-		return EXIT_FAILURE;
-	}
-
-	ctx->image = image_load(ctx->infilename);
-	if (!ctx->image)
-		return EXIT_FAILURE;
-
-	talloc_steal(ctx, ctx->image);
-
-	ERR_load_crypto_strings();
-	ERR_load_BIO_strings();
-	OpenSSL_add_all_digests();
-	OpenSSL_add_all_ciphers();
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
-	OPENSSL_config(NULL);
-#else
-	OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, NULL);
-#endif
-	/* here we may get highly unlikely failures or we'll get a
-	 * complaint about FIPS signatures (usually becuase the FIPS
-	 * module isn't present).  In either case ignore the errors
-	 * (malloc will cause other failures out lower down */
-	ERR_clear_error();
-	if (engine)
-		pkey = fileio_read_engine_key(engine, keyfilename);
-	else
-		pkey = fileio_read_pkey(keyfilename);
-	if (!pkey)
-		return EXIT_FAILURE;
-
-	X509 *cert = fileio_read_cert(certfilename);
-	if (!cert)
-		return EXIT_FAILURE;
-
-	const EVP_MD *md = EVP_get_digestbyname("SHA256");
-
-	/* set up the PKCS7 object */
-	PKCS7 *p7 = PKCS7_new();
-	PKCS7_set_type(p7, NID_pkcs7_signed);
-
-	PKCS7_SIGNER_INFO *si = PKCS7_sign_add_signer(p7, cert,
-			pkey, md, PKCS7_BINARY);
-	if (!si) {
-		fprintf(stderr, "error in key/certificate chain\n");
-		ERR_print_errors_fp(stderr);
-		return EXIT_FAILURE;
-	}
-
-	PKCS7_content_new(p7, NID_pkcs7_data);
-
-	rc = IDC_set(p7, si, ctx->image);
-	if (rc)
-		return EXIT_FAILURE;
-
-	if (addcertfilename && add_intermediate_certs(p7, addcertfilename))
-		return EXIT_FAILURE;
-
-	sigsize = i2d_PKCS7(p7, NULL);
-	tmp = buf = talloc_array(ctx->image, uint8_t, sigsize);
-	i2d_PKCS7(p7, &tmp);
-	ERR_print_errors_fp(stdout);
-
-	image_add_signature(ctx->image, buf, sigsize);
-
-	if (ctx->detached) {
-		int i;
-		uint8_t *buf;
-		size_t len;
-
-		for (i = 0; !image_get_signature(ctx->image, i, &buf, &len); i++)
-			;
-		rc = image_write_detached(ctx->image, i - 1, ctx->outfilename);
-	} else
-		rc = image_write(ctx->image, ctx->outfilename);
-
-	talloc_free(ctx);
-
-	return (rc == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
-}
-
--- tpmsbsigntool-0.9.4.orig/src/sbvarsign.c
+++ /dev/null
@@ -1,574 +0,0 @@
-/*
- * Copyright (C) 2012 Jeremy Kerr <jeremy.kerr@canonical.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 3
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
- * USA.
- *
- * In addition, as a special exception, the copyright holders give
- * permission to link the code of portions of this program with the OpenSSL
- * library under certain conditions as described in each individual source file,
- * and distribute linked combinations including the two.
- *
- * You must obey the GNU General Public License in all respects for all
- * of the code used other than OpenSSL. If you modify file(s) with this
- * exception, you may extend this exception to your version of the
- * file(s), but you are not obligated to do so. If you do not wish to do
- * so, delete this exception statement from your version. If you delete
- * this exception statement from all source files in the program, then
- * also delete it here.
- */
-#define _GNU_SOURCE
-
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <getopt.h>
-
-#include <uuid/uuid.h>
-
-#include <openssl/bio.h>
-#include <openssl/conf.h>
-#include <openssl/evp.h>
-#include <openssl/err.h>
-#include <openssl/pem.h>
-#include <openssl/pkcs7.h>
-
-#include <ccan/array_size/array_size.h>
-#include <ccan/read_write_all/read_write_all.h>
-#include <ccan/talloc/talloc.h>
-
-#include "efivars.h"
-#include "fileio.h"
-
-static const char *toolname = "sbvarsign";
-
-struct varsign_context {
-	const char			*infilename;
-	const char			*outfilename;
-
-	uint8_t				*data;
-	size_t				data_len;
-
-	CHAR16				*var_name;
-	int				var_name_bytes;
-	EFI_GUID			var_guid;
-	uint32_t			var_attrs;
-
-	EVP_PKEY			*key;
-	X509				*cert;
-
-	EFI_VARIABLE_AUTHENTICATION_2	*auth_descriptor;
-	int				auth_descriptor_len;
-	EFI_TIME			timestamp;
-
-	int				verbose;
-};
-
-struct attr {
-	const char	*name;
-	int		value;
-};
-
-#define EFI_VAR_ATTR(n) { #n, EFI_VARIABLE_ ## n }
-static struct attr attrs[] = {
-	EFI_VAR_ATTR(NON_VOLATILE),
-	EFI_VAR_ATTR(BOOTSERVICE_ACCESS),
-	EFI_VAR_ATTR(RUNTIME_ACCESS),
-	EFI_VAR_ATTR(TIME_BASED_AUTHENTICATED_WRITE_ACCESS),
-	EFI_VAR_ATTR(APPEND_WRITE),
-};
-
-static uint32_t default_attrs = EFI_VARIABLE_NON_VOLATILE |
-			EFI_VARIABLE_BOOTSERVICE_ACCESS |
-			EFI_VARIABLE_RUNTIME_ACCESS |
-			EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS |
-			EFI_VARIABLE_APPEND_WRITE;
-
-static uint32_t attr_invalid = 0xffffffffu;
-static const char *attr_prefix = "EFI_VARIABLE_";
-
-static const EFI_GUID cert_pkcs7_guid = EFI_CERT_TYPE_PKCS7_GUID;
-
-static void set_default_outfilename(struct varsign_context *ctx)
-{
-	const char *extension = "signed";
-
-	ctx->outfilename = talloc_asprintf(ctx, "%s.%s",
-			ctx->infilename, extension);
-}
-
-static uint32_t parse_single_attr(const char *attr_str)
-{
-	unsigned int i;
-
-	/* skip standard prefix, if present */
-	if (!strncmp(attr_str, attr_prefix, strlen(attr_prefix)))
-		attr_str += strlen(attr_prefix);
-
-	for (i = 0; i < ARRAY_SIZE(attrs); i++) {
-		if (!strcmp(attr_str, attrs[i].name))
-			return attrs[i].value;
-	}
-
-	return attr_invalid;
-}
-
-static uint32_t parse_attrs(const char *attrs_str)
-{
-	uint32_t attr, attrs_val;
-	const char *attr_str;
-	char *str;
-
-	/* we always need E_V_T_B_A_W_A */
-	attrs_val = EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS;
-
-	if (!attrs_str[0])
-		return attrs_val;
-
-	str = strdup(attrs_str);
-
-	for (attr_str = strtok(str, ","); attr_str;
-			attr_str = strtok(NULL, ",")) {
-
-		attr = parse_single_attr(attr_str);
-		if (attr == attr_invalid) {
-			fprintf(stderr, "Invalid attribute string %s\n",
-					attr_str);
-			return attr_invalid;
-		}
-
-		attrs_val |= attr;
-	}
-
-	return attrs_val;
-}
-
-static int set_varname(struct varsign_context *ctx, const char *str)
-{
-	CHAR16 *wstr;
-	int i, len;
-
-	len = strlen(str);
-
-	wstr = talloc_array(ctx, CHAR16, len);
-
-	for (i = 0; i < len; i++)
-		wstr[i] = str[i];
-
-	ctx->var_name = wstr;
-	ctx->var_name_bytes = len * sizeof(CHAR16);
-
-	return 0;
-}
-
-static int parse_guid(const char *str, EFI_GUID *guid)
-{
-	uuid_t uuid;
-
-	if (uuid_parse(str, uuid))
-		return -1;
-
-	/* convert to an EFI_GUID */
-	guid->Data1 = uuid[0] << 24 | uuid[1] << 16 | uuid[2] << 8 | uuid[3];
-	guid->Data2 = uuid[4] << 8 | uuid[5];
-	guid->Data3 = uuid[6] << 8 | uuid[7];
-	memcpy(guid->Data4, &uuid[8], sizeof(guid->Data4));
-
-	return 0;
-}
-
-static int set_timestamp(EFI_TIME *timestamp)
-{
-	struct tm *tm;
-	time_t t;
-
-	time(&t);
-
-	tm = gmtime(&t);
-	if (!tm) {
-		perror("gmtime");
-		return -1;
-	}
-
-	/* copy to our EFI-specific time structure. Other fields (Nanosecond,
-	 * TimeZone, Daylight and Pad) are defined to be zero */
-	memset(timestamp, 0, sizeof(*timestamp));
-	timestamp->Year = 1900 + tm->tm_year;
-	timestamp->Month = tm->tm_mon;
-	timestamp->Day = tm->tm_mday;
-	timestamp->Hour = tm->tm_hour;
-	timestamp->Minute = tm->tm_min;
-	timestamp->Second = tm->tm_sec;
-
-	return 0;
-}
-
-static int add_auth_descriptor(struct varsign_context *ctx)
-{
-	EFI_VARIABLE_AUTHENTICATION_2 *auth;
-	int rc, len, flags;
-	EFI_TIME timestamp;
-	const EVP_MD *md;
-	BIO *data_bio;
-	uint8_t *tmp;
-	PKCS7 *p7;
-
-	if (set_timestamp(&timestamp))
-		return -1;
-
-	/* create a BIO for our variable data, containing:
-	 *  * Variablename (not including trailing nul)
-	 *  * VendorGUID
-	 *  * Attributes
-	 *  * TimeStamp
-	 *  * Data
-	 */
-	data_bio = BIO_new(BIO_s_mem());
-	BIO_write(data_bio, ctx->var_name, ctx->var_name_bytes);
-	BIO_write(data_bio, &ctx->var_guid, sizeof(ctx->var_guid));
-	BIO_write(data_bio, &ctx->var_attrs, sizeof(ctx->var_attrs));
-	BIO_write(data_bio, &timestamp, sizeof(timestamp));
-	BIO_write(data_bio, ctx->data, ctx->data_len);
-
-	md = EVP_get_digestbyname("SHA256");
-
-	p7 = PKCS7_new();
-	flags = PKCS7_BINARY | PKCS7_DETACHED | PKCS7_NOSMIMECAP;;
-	PKCS7_set_type(p7, NID_pkcs7_signed);
-
-	PKCS7_content_new(p7, NID_pkcs7_data);
-
-	PKCS7_sign_add_signer(p7, ctx->cert, ctx->key, md, flags);
-
-	PKCS7_set_detached(p7, 1);
-
-	rc = PKCS7_final(p7, data_bio, flags);
-	if (!rc) {
-		fprintf(stderr, "Error signing variable data\n");
-		ERR_print_errors_fp(stderr);
-		BIO_free_all(data_bio);
-		return -1;
-	}
-
-	len = i2d_PKCS7_SIGNED(p7->d.sign, NULL);
-
-
-	/* set up our auth descriptor */
-	auth = talloc_size(ctx, sizeof(*auth) + len);
-
-	auth->TimeStamp = timestamp;
-	auth->AuthInfo.Hdr.dwLength = len + sizeof(auth->AuthInfo);
-	auth->AuthInfo.Hdr.wRevision = 0x0200;
-	auth->AuthInfo.Hdr.wCertificateType = 0x0EF1;
-	auth->AuthInfo.CertType = cert_pkcs7_guid;
-	tmp = auth->AuthInfo.CertData;
-	i2d_PKCS7_SIGNED(p7->d.sign, &tmp);
-
-	ctx->auth_descriptor = auth;
-	ctx->auth_descriptor_len = sizeof(*auth) + len;
-
-	BIO_free_all(data_bio);
-
-	return 0;
-}
-
-int write_signed(struct varsign_context *ctx, int include_attrs)
-{
-	int fd, rc;
-
-	fd = open(ctx->outfilename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-	if (fd < 0) {
-		perror("open");
-		goto err;
-	}
-
-	/* For some uses (eg, writing to the efivars filesystem), we may
-	 * want to prefix the signed variable with four bytes of attribute
-	 * data
-	 */
-	if (include_attrs) {
-		rc = write_all(fd, &ctx->var_attrs, sizeof(ctx->var_attrs));
-		if (!rc) {
-			perror("write_all");
-			goto err;
-		}
-	}
-
-	/* Write the authentication descriptor */
-	rc = write_all(fd, ctx->auth_descriptor, ctx->auth_descriptor_len);
-	if (!rc) {
-		perror("write_all");
-		goto err;
-	}
-
-	/* ... and the variable data itself */
-	rc = write_all(fd, ctx->data, ctx->data_len);
-	if (!rc) {
-		perror("write_all");
-		goto err;
-	}
-
-	if (ctx->verbose) {
-		size_t i = 0;
-
-		printf("Wrote signed data:\n");
-		if (include_attrs) {
-			i = sizeof(ctx->var_attrs);
-			printf("  [%04lx:%04zx] attrs\n", 0l, i);
-		}
-
-		printf("  [%04zx:%04x] authentication descriptor\n",
-				i, ctx->auth_descriptor_len);
-
-		printf("    [%04zx:%04zx] EFI_VAR_AUTH_2 header\n",
-				i,
-				sizeof(EFI_VARIABLE_AUTHENTICATION_2));
-
-		printf("    [%04zx:%04zx] WIN_CERT_UEFI_GUID header\n",
-				i + offsetof(EFI_VARIABLE_AUTHENTICATION_2,
-					AuthInfo),
-				sizeof(WIN_CERTIFICATE_UEFI_GUID));
-
-		printf("    [%04zx:%04zx] WIN_CERT header\n",
-				i + offsetof(EFI_VARIABLE_AUTHENTICATION_2,
-					AuthInfo.Hdr),
-				sizeof(WIN_CERTIFICATE));
-
-		printf("    [%04zx:%04zx] pkcs7 data\n",
-				i + offsetof(EFI_VARIABLE_AUTHENTICATION_2,
-					AuthInfo.CertData),
-				ctx->auth_descriptor_len -
-					sizeof(EFI_VARIABLE_AUTHENTICATION_2));
-
-		i += ctx->auth_descriptor_len;
-
-		printf("  [%04zx:%04zx] variable data\n",
-				i, i + ctx->data_len);
-	}
-
-	close(fd);
-	return 0;
-
-err:
-	fprintf(stderr, "Can't write signed data to file '%s'\n",
-			ctx->outfilename);
-	if (fd >= 0)
-		close(fd);
-	return -1;
-
-}
-
-static void set_default_guid(struct varsign_context *ctx, const char *varname)
-{
-	EFI_GUID secdb_guid = EFI_IMAGE_SECURITY_DATABASE_GUID;
-	EFI_GUID global_guid = EFI_GLOBAL_VARIABLE;
-
-	if (!strcmp(varname, "db") || !strcmp(varname, "dbx"))
-		ctx->var_guid = secdb_guid;
-	else
-		ctx->var_guid = global_guid;
-}
-
-static struct option options[] = {
-	{ "output", required_argument, NULL, 'o' },
-	{ "guid", required_argument, NULL, 'g' },
-	{ "attrs", required_argument, NULL, 'a' },
-	{ "key", required_argument, NULL, 'k' },
-	{ "cert", required_argument, NULL, 'c' },
-	{ "include-attrs", no_argument, NULL, 'i' },
-	{ "verbose", no_argument, NULL, 'v' },
-	{ "help", no_argument, NULL, 'h' },
-	{ "version", no_argument, NULL, 'V' },
-	{ "engine", required_argument, NULL, 'e'},
-	{ NULL, 0, NULL, 0 },
-};
-
-void usage(void)
-{
-	unsigned int i;
-
-	printf("Usage: %s [options] --key <keyfile> --cert <certfile> "
-			"<var-name> <var-data-file>\n"
-		"Sign a blob of data for use in SetVariable().\n\n"
-		"Options:\n"
-		"\t--engine <eng>     use the specified engine to load the key\n"
-		"\t--key <keyfile>    signing key (PEM-encoded RSA "
-						"private key)\n"
-		"\t--cert <certfile>  certificate (x509 certificate)\n"
-		"\t--include-attrs  include attrs at beginning of output file\n"
-		"\t--guid <GUID>    EFI GUID for the variable. If omitted,\n"
-		"\t                  EFI_IMAGE_SECURITY_DATABASE or\n"
-		"\t                  EFI_GLOBAL_VARIABLE (depending on\n"
-		"\t                  <var-name>) will be used.\n"
-		"\t--attr <attrs>   variable attributes. One or more of:\n",
-		toolname);
-
-	for (i = 0; i < ARRAY_SIZE(attrs); i++)
-		printf("\t                     %s\n", attrs[i].name);
-
-	printf("\t                  Separate multiple attrs with a comma,\n"
-		"\t                  default is all attributes,\n"
-		"\t                  TIME_BASED_AUTH... is always included.\n"
-		"\t--output <file>  write signed data to <file>\n"
-		"\t                  (default <var-data-file>.signed)\n");
-}
-
-static void version(void)
-{
-	printf("%s %s\n", toolname, VERSION);
-}
-
-int main(int argc, char **argv)
-{
-	const char *guid_str, *attr_str, *varname, *engine;
-	const char *keyfilename, *certfilename;
-	struct varsign_context *ctx;
-	bool include_attrs;
-	int c;
-
-	ctx = talloc_zero(NULL, struct varsign_context);
-
-	keyfilename = NULL;
-	certfilename = NULL;
-	engine = NULL;
-	guid_str = NULL;
-	attr_str= NULL;
-	include_attrs = false;
-
-	for (;;) {
-		int idx;
-		c = getopt_long(argc, argv, "o:g:a:k:c:ivVhe:", options, &idx);
-		if (c == -1)
-			break;
-
-		switch (c) {
-		case 'o':
-			ctx->outfilename = optarg;
-			break;
-		case 'g':
-			guid_str = optarg;
-			break;
-		case 'a':
-			attr_str = optarg;
-			break;
-		case 'k':
-			keyfilename = optarg;
-			break;
-		case 'c':
-			certfilename = optarg;
-			break;
-		case 'i':
-			include_attrs = true;
-			break;
-		case 'v':
-			ctx->verbose = 1;
-			break;
-		case 'V':
-			version();
-			return EXIT_SUCCESS;
-		case 'h':
-			usage();
-			return EXIT_SUCCESS;
-		case 'e':
-			engine = optarg;
-			break;
-		}
-	}
-
-	if (argc != optind + 2) {
-		usage();
-		return EXIT_FAILURE;
-	}
-
-	if (!keyfilename) {
-		fprintf(stderr, "No signing key specified\n");
-		return EXIT_FAILURE;
-	}
-
-	if (!certfilename) {
-		fprintf(stderr, "No signing certificate specified\n");
-		return EXIT_FAILURE;
-	}
-
-	/* initialise openssl */
-	OpenSSL_add_all_digests();
-	OpenSSL_add_all_ciphers();
-	ERR_load_crypto_strings();
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
-	OPENSSL_config(NULL);
-#else
-	OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, NULL);
-#endif
-	/* here we may get highly unlikely failures or we'll get a
-	 * complaint about FIPS signatures (usually becuase the FIPS
-	 * module isn't present).  In either case ignore the errors
-	 * (malloc will cause other failures out lower down */
-	ERR_clear_error();
-
-	/* set up the variable signing context */
-	varname = argv[optind];
-	set_varname(ctx, varname);
-	ctx->infilename = argv[optind+1];
-
-	if (!ctx->outfilename)
-		set_default_outfilename(ctx);
-
-	if (attr_str) {
-		ctx->var_attrs = parse_attrs(attr_str);
-		if (ctx->var_attrs == attr_invalid)
-			return EXIT_FAILURE;
-	} else {
-		ctx->var_attrs = default_attrs;
-	}
-
-	if (guid_str) {
-		if (parse_guid(guid_str, &ctx->var_guid)) {
-			fprintf(stderr, "Invalid GUID '%s'\n", guid_str);
-			return EXIT_FAILURE;
-		}
-	} else {
-		set_default_guid(ctx, varname);
-	}
-
-	if (fileio_read_file(ctx, ctx->infilename, &ctx->data, &ctx->data_len))
-		return EXIT_FAILURE;
-
-	if (engine)
-		ctx->key = fileio_read_engine_key(engine, keyfilename);
-	else
-		ctx->key = fileio_read_pkey(keyfilename);
-	if (!ctx->key)
-		return EXIT_FAILURE;
-
-	ctx->cert = fileio_read_cert(certfilename);
-	if (!ctx->cert)
-		return EXIT_FAILURE;
-
-	/* do the signing */
-	if (add_auth_descriptor(ctx))
-		return EXIT_FAILURE;
-
-	/* write the resulting image */
-	if (write_signed(ctx, include_attrs))
-		return EXIT_FAILURE;
-
-	return EXIT_SUCCESS;
-}
--- tpmsbsigntool-0.9.4.orig/src/sbverify.c
+++ /dev/null
@@ -1,391 +0,0 @@
-/*
- * Copyright (C) 2012 Jeremy Kerr <jeremy.kerr@canonical.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 3
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
- * USA.
- *
- * In addition, as a special exception, the copyright holders give
- * permission to link the code of portions of this program with the OpenSSL
- * library under certain conditions as described in each individual source file,
- * and distribute linked combinations including the two.
- *
- * You must obey the GNU General Public License in all respects for all
- * of the code used other than OpenSSL. If you modify file(s) with this
- * exception, you may extend this exception to your version of the
- * file(s), but you are not obligated to do so. If you do not wish to do
- * so, delete this exception statement from your version. If you delete
- * this exception statement from all source files in the program, then
- * also delete it here.
- */
-#define _GNU_SOURCE
-
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
-#include <getopt.h>
-
-#include <ccan/talloc/talloc.h>
-#include <ccan/read_write_all/read_write_all.h>
-
-#include "image.h"
-#include "idc.h"
-#include "fileio.h"
-
-#include <openssl/conf.h>
-#include <openssl/err.h>
-#include <openssl/bio.h>
-#include <openssl/evp.h>
-#include <openssl/pkcs7.h>
-#include <openssl/pem.h>
-#include <openssl/x509v3.h>
-
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
-#define X509_OBJECT_get0_X509(obj) ((obj)->data.x509)
-#define X509_OBJECT_get_type(obj) ((obj)->type)
-#define X509_STORE_CTX_get0_cert(ctx) ((ctx)->cert)
-#define X509_STORE_get0_objects(certs) ((certs)->objs)
-#define X509_get_extended_key_usage(cert) ((cert)->ex_xkusage)
-#if OPENSSL_VERSION_NUMBER < 0x10020000L
-#define X509_STORE_CTX_get0_store(ctx) ((ctx)->ctx)
-#endif
-#endif
-
-static const char *toolname = "sbverify";
-static const int cert_name_len = 160;
-
-enum verify_status {
-	VERIFY_FAIL = 0,
-	VERIFY_OK = 1,
-};
-
-static struct option options[] = {
-	{ "cert", required_argument, NULL, 'c' },
-	{ "list", no_argument, NULL, 'l' },
-	{ "detached", required_argument, NULL, 'd' },
-	{ "verbose", no_argument, NULL, 'v' },
-	{ "help", no_argument, NULL, 'h' },
-	{ "version", no_argument, NULL, 'V' },
-	{ NULL, 0, NULL, 0 },
-};
-
-static void usage(void)
-{
-	printf("Usage: %s [options] --cert <certfile> <efi-boot-image>\n"
-		"Verify a UEFI secure boot image.\n\n"
-		"Options:\n"
-		"\t--cert <certfile>  certificate (x509 certificate)\n"
-		"\t--list             list all signatures (but don't verify)\n"
-		"\t--detached <file>  read signature from <file>, instead of\n"
-		"\t                    looking for an embedded signature\n",
-			toolname);
-}
-
-static void version(void)
-{
-	printf("%s %s\n", toolname, VERSION);
-}
-
-int load_cert(X509_STORE *certs, const char *filename)
-{
-	X509 *cert;
-
-	cert = fileio_read_cert(filename);
-	if (!cert)
-		return -1;
-
-	X509_STORE_add_cert(certs, cert);
-	return 0;
-}
-
-static void print_signature_info(PKCS7 *p7)
-{
-	char subject_name[cert_name_len + 1], issuer_name[cert_name_len + 1];
-	PKCS7_SIGNER_INFO *si;
-	X509 *cert;
-	int i;
-
-	printf("image signature issuers:\n");
-
-	for (i = 0; i < sk_PKCS7_SIGNER_INFO_num(p7->d.sign->signer_info);
-			i++) {
-		si = sk_PKCS7_SIGNER_INFO_value(p7->d.sign->signer_info, i);
-		X509_NAME_oneline(si->issuer_and_serial->issuer,
-				issuer_name, cert_name_len);
-		printf(" - %s\n", issuer_name);
-	}
-
-	printf("image signature certificates:\n");
-
-	for (i = 0; i < sk_X509_num(p7->d.sign->cert); i++) {
-		cert = sk_X509_value(p7->d.sign->cert, i);
-		X509_NAME_oneline(X509_get_subject_name(cert),
-				subject_name, cert_name_len);
-		X509_NAME_oneline(X509_get_issuer_name(cert),
-				issuer_name, cert_name_len);
-
-		printf(" - subject: %s\n", subject_name);
-		printf("   issuer:  %s\n", issuer_name);
-	}
-}
-
-static void print_certificate_store_certs(X509_STORE *certs)
-{
-	char subject_name[cert_name_len + 1], issuer_name[cert_name_len + 1];
-	STACK_OF(X509_OBJECT) *objs;
-	X509_OBJECT *obj;
-	X509 *cert;
-	int i;
-
-	printf("certificate store:\n");
-
-	objs = X509_STORE_get0_objects(certs);
-
-	for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {
-		obj = sk_X509_OBJECT_value(objs, i);
-
-		if (X509_OBJECT_get_type(obj) != X509_LU_X509)
-			continue;
-
-		cert = X509_OBJECT_get0_X509(obj);
-
-		X509_NAME_oneline(X509_get_subject_name(cert),
-				subject_name, cert_name_len);
-		X509_NAME_oneline(X509_get_issuer_name(cert),
-				issuer_name, cert_name_len);
-
-		printf(" - subject: %s\n", subject_name);
-		printf("   issuer:  %s\n", issuer_name);
-	}
-}
-
-static int load_detached_signature_data(struct image *image,
-		const char *filename, uint8_t **buf, size_t *len)
-{
-	return fileio_read_file(image, filename, buf, len);
-}
-
-static int cert_in_store(X509 *cert, X509_STORE_CTX *ctx)
-{
-	STACK_OF(X509_OBJECT) *objs;
-	X509_OBJECT *obj;
-	int i;
-
-	objs = X509_STORE_get0_objects(X509_STORE_CTX_get0_store(ctx));
-
-	for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {
-		obj = sk_X509_OBJECT_value(objs, i);
-
-		if (X509_OBJECT_get_type(obj) == X509_LU_X509 &&
-		    !X509_cmp(X509_OBJECT_get0_X509(obj), cert))
-			return 1;
-	}
-
-	return 0;
-}
-
-static int x509_verify_cb(int status, X509_STORE_CTX *ctx)
-{
-	int err = X509_STORE_CTX_get_error(ctx);
-
-	/* also accept code-signing keys */
-	if (err == X509_V_ERR_INVALID_PURPOSE &&
-			X509_get_extended_key_usage(X509_STORE_CTX_get0_cert(ctx))
-			== XKU_CODE_SIGN)
-		status = 1;
-
-	else if (err == X509_V_ERR_CERT_UNTRUSTED ||
-		 err == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT ||
-		 err == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE) {
-		/* all certs given with the --cert argument are trusted */
-
-		if (cert_in_store(X509_STORE_CTX_get_current_cert(ctx), ctx))
-			status = 1;
-	} else if (err == X509_V_ERR_CERT_HAS_EXPIRED ||
-		   err == X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD ||
-		   err == X509_V_ERR_CERT_NOT_YET_VALID ||
-		   err == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY ||
-		   err == X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD)
-		/* UEFI explicitly allows expired certificates */
-		status = 1;
-
-	return status;
-}
-
-int main(int argc, char **argv)
-{
-	const char *detached_sig_filename, *image_filename;
-	enum verify_status status;
-	int rc, c, flags, list;
-	const uint8_t *tmp_buf;
-	struct image *image;
-	X509_STORE *certs;
-	uint8_t *sig_buf;
-	size_t sig_size;
-	struct idc *idc;
-	int verbose;
-	BIO *idcbio;
-	PKCS7 *p7;
-	int sig_count = 0;
-
-	status = VERIFY_FAIL;
-	certs = X509_STORE_new();
-	list = 0;
-	verbose = 0;
-	detached_sig_filename = NULL;
-
-	OpenSSL_add_all_digests();
-	ERR_load_crypto_strings();
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
-	OPENSSL_config(NULL);
-#else
-	OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, NULL);
-#endif
-	/* here we may get highly unlikely failures or we'll get a
-	 * complaint about FIPS signatures (usually becuase the FIPS
-	 * module isn't present).  In either case ignore the errors
-	 * (malloc will cause other failures out lower down */
-	ERR_clear_error();
-
-	for (;;) {
-		int idx;
-		c = getopt_long(argc, argv, "c:d:lvVh", options, &idx);
-		if (c == -1)
-			break;
-
-		switch (c) {
-		case 'c':
-			rc = load_cert(certs, optarg);
-			if (rc)
-				return EXIT_FAILURE;
-			break;
-		case 'd':
-			detached_sig_filename = optarg;
-			break;
-		case 'l':
-			list = 1;
-			break;
-		case 'v':
-			verbose++;
-			break;
-		case 'V':
-			version();
-			return EXIT_SUCCESS;
-		case 'h':
-			usage();
-			return EXIT_SUCCESS;
-		}
-
-	}
-
-	if (argc != optind + 1) {
-		usage();
-		return EXIT_FAILURE;
-	}
-
-	image_filename = argv[optind];
-
-	image = image_load(image_filename);
-	if (!image) {
-		fprintf(stderr, "Can't open image %s\n", image_filename);
-		return EXIT_FAILURE;
-	}
-
-	for (;;) {
-		if (detached_sig_filename) {
-			if (sig_count++)
-				break;
-
-			rc = load_detached_signature_data(image, detached_sig_filename,
-							  &sig_buf, &sig_size);
-		} else
-			rc = image_get_signature(image, sig_count++, &sig_buf, &sig_size);
-
-		if (rc) {
-			if (sig_count == 0) {
-				fprintf(stderr, "Unable to read signature data from %s\n",
-					detached_sig_filename ? : image_filename);
-			}
-			break;
-		}
-
-		tmp_buf = sig_buf;
-		if (verbose || list)
-			printf("signature %d\n", sig_count);
-		p7 = d2i_PKCS7(NULL, &tmp_buf, sig_size);
-		if (!p7) {
-			fprintf(stderr, "Unable to parse signature data\n");
-			ERR_print_errors_fp(stderr);
-			break;
-		}
-
-		if (verbose || list) {
-			print_signature_info(p7);
-			if (verbose > 1)
-				print_certificate_store_certs(certs);
-		}
-
-		if (list)
-			continue;
-
-		idcbio = BIO_new(BIO_s_mem());
-		idc = IDC_get(p7, idcbio);
-		if (!idc) {
-			fprintf(stderr, "Unable to get IDC from PKCS7\n");
-			break;
-		}
-
-		rc = IDC_check_hash(idc, image);
-		if (rc) {
-			fprintf(stderr, "Image fails hash check\n");
-			break;
-		}
-
-		flags = PKCS7_BINARY;
-
-		/* OpenSSL 1.0.2e no longer allows calling PKCS7_verify with
-		 * both data and content. Empty out the content. */
-		p7->d.sign->contents->d.ptr = NULL;
-
-		X509_STORE_set_verify_cb_func(certs, x509_verify_cb);
-		rc = PKCS7_verify(p7, NULL, certs, idcbio, NULL, flags);
-		if (rc) {
-			if (verbose)
-				printf("PKCS7 verification passed\n");
-
-			status = VERIFY_OK;
-		} else if (verbose) {
-			printf("PKCS7 verification failed\n");
-			ERR_print_errors_fp(stderr);
-		}
-
-	}
-
-	talloc_free(image);
-
-	if (list)
-		exit(EXIT_SUCCESS);
-
-	if (status == VERIFY_OK)
-		printf("Signature verification OK\n");
-	else
-		printf("Signature verification failed\n");
-
-	return status == VERIFY_OK ? EXIT_SUCCESS : EXIT_FAILURE;
-}
--- /dev/null
+++ tpmsbsigntool-0.9.4/src/tpmkmodsign.c
@@ -0,0 +1,352 @@
+/* Sign a module file using the given key.
+ *
+ * Copyright © 2014-2015 Red Hat, Inc. All Rights Reserved.
+ * Copyright © 2015      Intel Corporation.
+ *
+ * Authors: David Howells <dhowells@redhat.com>
+ *          David Woodhouse <dwmw2@infradead.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1
+ * of the licence, or (at your option) any later version.
+ */
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include <getopt.h>
+#include <err.h>
+#include <arpa/inet.h>
+#include <openssl/opensslv.h>
+#include <openssl/bio.h>
+#include <openssl/evp.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/engine.h>
+
+/*
+ * Use CMS if we have openssl-1.0.0 or newer available - otherwise we have to
+ * assume that it's not available and its header file is missing and that we
+ * should use PKCS#7 instead.  Switching to the older PKCS#7 format restricts
+ * the options we have on specifying the X.509 certificate we want.
+ *
+ * Further, older versions of OpenSSL don't support manually adding signers to
+ * the PKCS#7 message so have to accept that we get a certificate included in
+ * the signature message.  Nor do such older versions of OpenSSL support
+ * signing with anything other than SHA1 - so we're stuck with that if such is
+ * the case.
+ */
+#if OPENSSL_VERSION_NUMBER < 0x10000000L
+#define USE_PKCS7
+#endif
+#ifndef USE_PKCS7
+#include <openssl/cms.h>
+#else
+#include <openssl/pkcs7.h>
+#endif
+
+struct module_signature {
+	uint8_t		algo;		/* Public-key crypto algorithm [0] */
+	uint8_t		hash;		/* Digest algorithm [0] */
+	uint8_t		id_type;	/* Key identifier type [PKEY_ID_PKCS7] */
+	uint8_t		signer_len;	/* Length of signer's name [0] */
+	uint8_t		key_id_len;	/* Length of key identifier [0] */
+	uint8_t		__pad[3];
+	uint32_t	sig_len;	/* Length of signature data */
+};
+
+#define PKEY_ID_PKCS7 2
+
+static char magic_number[] = "~Module signature appended~\n";
+
+static void usage(void)
+{
+	printf("Usage: tpmkmodsign [-dpkD] <hash algo> <key> <x509> <module> [<dest>]\n"
+		"Sign a kernel module image for use with an enforcing kernel.\n\n"
+		"Options:\n"
+		"\t-p           save a copy of the p7s signature (.p7s)\n"
+		"\t-d           produce a detached signature file (.p7s) only\n"
+		"\t-D           produce a full detached signature block\n"
+		"\t             (may be cat'd onto the end of a module)\n"
+		"\t-k           switch to using keyid for identification\n");
+}
+static void version(void)
+{
+	printf("tpmkmodsign 4.4\n");
+}
+
+static __attribute__((noreturn))
+void format(void)
+{
+	usage();
+	exit(2);
+}
+
+static void display_openssl_errors(int l)
+{
+	const char *file;
+	char buf[120];
+	int e, line;
+
+	if (ERR_peek_error() == 0)
+		return;
+	fprintf(stderr, "At main.c:%d:\n", l);
+
+	while ((e = ERR_get_error_line(&file, &line))) {
+		ERR_error_string(e, buf);
+		fprintf(stderr, "- SSL %s: %s:%d\n", buf, file, line);
+	}
+}
+
+static void drain_openssl_errors(void)
+{
+	const char *file;
+	int line;
+
+	if (ERR_peek_error() == 0)
+		return;
+	while (ERR_get_error_line(&file, &line)) {}
+}
+
+#define ERR(cond, fmt, ...)				\
+	do {						\
+		bool __cond = (cond);			\
+		display_openssl_errors(__LINE__);	\
+		if (__cond) {				\
+			err(1, fmt, ## __VA_ARGS__);	\
+		}					\
+	} while(0)
+
+static const char *key_pass;
+
+static int pem_pw_cb(char *buf, int len, int w __attribute__((unused)),
+		     void *v __attribute__((unused)))
+{
+	int pwlen;
+
+	if (!key_pass)
+		return -1;
+
+	pwlen = strlen(key_pass);
+	if (pwlen >= len)
+		return -1;
+
+	strcpy(buf, key_pass);
+
+	/* If it's wrong, don't keep trying it. */
+	key_pass = NULL;
+
+	return pwlen;
+}
+
+static struct option options[] = {
+	{ "version", no_argument, NULL, 'V' },
+	{ "help", no_argument, NULL, 'h' },
+	{ NULL, 0, NULL, 0 },
+};
+
+int main(int argc, char **argv)
+{
+	struct module_signature sig_info = { .id_type = PKEY_ID_PKCS7 };
+	char *hash_algo = NULL;
+	char *private_key_name, *x509_name, *module_name, *dest_name;
+	bool save_sig = false, replace_orig;
+	bool sign_only = false;
+	bool detached = false;
+	unsigned char buf[4096];
+	unsigned long module_size, sig_size;
+	unsigned int use_signed_attrs;
+	const EVP_MD *digest_algo;
+	EVP_PKEY *private_key;
+#ifndef USE_PKCS7
+	CMS_ContentInfo *cms;
+	unsigned int use_keyid = 0;
+#else
+	PKCS7 *pkcs7;
+#endif
+	X509 *x509;
+	BIO *b, *bd = NULL, *bm;
+	int opt, n;
+	OpenSSL_add_all_algorithms();
+	ERR_load_crypto_strings();
+	ERR_clear_error();
+
+	key_pass = getenv("KBUILD_SIGN_PIN");
+
+#ifndef USE_PKCS7
+	use_signed_attrs = CMS_NOATTR;
+#else
+	use_signed_attrs = PKCS7_NOATTR;
+#endif
+
+	do {
+		int idx;
+		opt = getopt_long(argc, argv, "dpkDhV", options, &idx);
+		switch (opt) {
+		case 'p': save_sig = true; break;
+		case 'd': sign_only = true; save_sig = true; break;
+		case 'D': detached = true; break;
+#ifndef USE_PKCS7
+		case 'k': use_keyid = CMS_USE_KEYID; break;
+#endif
+		case 'V': version(); exit(0); break;
+		case 'h': usage(); exit(0); break;
+		case -1: break;
+		default: format();
+		}
+	} while (opt != -1);
+
+	argc -= optind;
+	argv += optind;
+	if (argc < 4 || argc > 5)
+		format();
+
+	hash_algo = argv[0];
+	private_key_name = argv[1];
+	x509_name = argv[2];
+	module_name = argv[3];
+	if (argc == 5) {
+		dest_name = argv[4];
+		replace_orig = false;
+	} else {
+		ERR(asprintf(&dest_name, "%s.~signed~", module_name) < 0,
+		    "asprintf");
+		replace_orig = true;
+	}
+
+#ifdef USE_PKCS7
+	if (strcmp(hash_algo, "sha1") != 0) {
+		fprintf(stderr, "tpmkmodsign %s only supports SHA1 signing\n",
+			OPENSSL_VERSION_TEXT);
+		exit(3);
+	}
+#endif
+
+	/* Read the private key and the X.509 cert the PKCS#7 message
+	 * will point to.
+	 */
+	if (!strncmp(private_key_name, "pkcs11:", 7)) {
+		ENGINE *e;
+
+		ENGINE_load_builtin_engines();
+		drain_openssl_errors();
+		e = ENGINE_by_id("pkcs11");
+		ERR(!e, "Load PKCS#11 ENGINE");
+		if (ENGINE_init(e))
+			drain_openssl_errors();
+		else
+			ERR(1, "ENGINE_init");
+		if (key_pass)
+			ERR(!ENGINE_ctrl_cmd_string(e, "PIN", key_pass, 0), "Set PKCS#11 PIN");
+		private_key = ENGINE_load_private_key(e, private_key_name, NULL,
+						      NULL);
+		ERR(!private_key, "%s", private_key_name);
+	} else {
+		b = BIO_new_file(private_key_name, "rb");
+		ERR(!b, "%s", private_key_name);
+		private_key = PEM_read_bio_PrivateKey(b, NULL, pem_pw_cb, NULL);
+		ERR(!private_key, "%s", private_key_name);
+		BIO_free(b);
+	}
+
+	b = BIO_new_file(x509_name, "rb");
+	ERR(!b, "%s", x509_name);
+	x509 = d2i_X509_bio(b, NULL); /* Binary encoded X.509 */
+	if (!x509) {
+		ERR(BIO_reset(b) != 1, "%s", x509_name);
+		x509 = PEM_read_bio_X509(b, NULL, NULL, NULL); /* PEM encoded X.509 */
+		if (x509)
+			drain_openssl_errors();
+	}
+	BIO_free(b);
+	ERR(!x509, "%s", x509_name);
+
+	/* Open the destination file now so that we can shovel the module data
+	 * across as we read it.
+	 */
+	if (!sign_only) {
+		bd = BIO_new_file(dest_name, "wb");
+		ERR(!bd, "%s", dest_name);
+	}
+
+	/* Digest the module data. */
+	OpenSSL_add_all_digests();
+	display_openssl_errors(__LINE__);
+	digest_algo = EVP_get_digestbyname(hash_algo);
+	ERR(!digest_algo, "EVP_get_digestbyname");
+
+	bm = BIO_new_file(module_name, "rb");
+	ERR(!bm, "%s", module_name);
+
+#ifndef USE_PKCS7
+	/* Load the signature message from the digest buffer. */
+	cms = CMS_sign(NULL, NULL, NULL, NULL,
+		       CMS_NOCERTS | CMS_PARTIAL | CMS_BINARY | CMS_DETACHED | CMS_STREAM);
+	ERR(!cms, "CMS_sign");
+
+	ERR(!CMS_add1_signer(cms, x509, private_key, digest_algo,
+			     CMS_NOCERTS | CMS_BINARY | CMS_NOSMIMECAP |
+			     use_keyid | use_signed_attrs),
+	    "CMS_add1_signer");
+	ERR(CMS_final(cms, bm, NULL, CMS_NOCERTS | CMS_BINARY) < 0,
+	    "CMS_final");
+
+#else
+	pkcs7 = PKCS7_sign(x509, private_key, NULL, bm,
+			   PKCS7_NOCERTS | PKCS7_BINARY |
+			   PKCS7_DETACHED | use_signed_attrs);
+	ERR(!pkcs7, "PKCS7_sign");
+#endif
+
+	if (save_sig) {
+		char *sig_file_name;
+
+		ERR(asprintf(&sig_file_name, "%s.p7s", module_name) < 0,
+		    "asprintf");
+		b = BIO_new_file(sig_file_name, "wb");
+		ERR(!b, "%s", sig_file_name);
+#ifndef USE_PKCS7
+		ERR(i2d_CMS_bio_stream(b, cms, NULL, 0) < 0,
+		    "%s", sig_file_name);
+#else
+		ERR(i2d_PKCS7_bio(b, pkcs7) < 0,
+			"%s", sig_file_name);
+#endif
+		BIO_free(b);
+	}
+
+	if (sign_only)
+		return 0;
+
+	/* Append the marker and the PKCS#7 message to the destination file */
+	if (!detached) {
+		ERR(BIO_reset(bm) < 0, "%s", module_name);
+		while ((n = BIO_read(bm, buf, sizeof(buf))),
+		       n > 0) {
+			ERR(BIO_write(bd, buf, n) < 0, "%s", dest_name);
+		}
+		ERR(n < 0, "%s", module_name);
+	}
+	module_size = BIO_number_written(bd);
+
+#ifndef USE_PKCS7
+	ERR(i2d_CMS_bio_stream(bd, cms, NULL, 0) < 0, "%s", dest_name);
+#else
+	ERR(i2d_PKCS7_bio(bd, pkcs7) < 0, "%s", dest_name);
+#endif
+	sig_size = BIO_number_written(bd) - module_size;
+	sig_info.sig_len = htonl(sig_size);
+	ERR(BIO_write(bd, &sig_info, sizeof(sig_info)) < 0, "%s", dest_name);
+	ERR(BIO_write(bd, magic_number, sizeof(magic_number) - 1) < 0, "%s", dest_name);
+
+	ERR(BIO_free(bd) < 0, "%s", dest_name);
+
+	/* Finally, if we're signing in place, replace the original. */
+	if (replace_orig)
+		ERR(rename(dest_name, module_name) < 0, "%s", dest_name);
+
+	return 0;
+}
--- /dev/null
+++ tpmsbsigntool-0.9.4/src/tpmsbsign.c
@@ -0,0 +1,303 @@
+/*
+ * Copyright (C) 2012 Jeremy Kerr <jeremy.kerr@canonical.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 3
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
+ * USA.
+ *
+ * In addition, as a special exception, the copyright holders give
+ * permission to link the code of portions of this program with the OpenSSL
+ * library under certain conditions as described in each individual source file,
+ * and distribute linked combinations including the two.
+ *
+ * You must obey the GNU General Public License in all respects for all
+ * of the code used other than OpenSSL. If you modify file(s) with this
+ * exception, you may extend this exception to your version of the
+ * file(s), but you are not obligated to do so. If you do not wish to do
+ * so, delete this exception statement from your version. If you delete
+ * this exception statement from all source files in the program, then
+ * also delete it here.
+ */
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <string.h>
+
+#include <getopt.h>
+
+#include <openssl/conf.h>
+#include <openssl/pem.h>
+#include <openssl/pkcs7.h>
+#include <openssl/err.h>
+#include <openssl/evp.h>
+#include <openssl/asn1.h>
+#include <openssl/asn1t.h>
+#include <openssl/bio.h>
+#include <openssl/x509.h>
+
+#include <ccan/talloc/talloc.h>
+
+#include "idc.h"
+#include "image.h"
+#include "fileio.h"
+
+static const char *toolname = "tpmsbsign";
+
+struct sign_context {
+	struct image *image;
+	const char *infilename;
+	const char *outfilename;
+	int verbose;
+	int detached;
+};
+
+static struct option options[] = {
+	{ "output", required_argument, NULL, 'o' },
+	{ "cert", required_argument, NULL, 'c' },
+	{ "key", required_argument, NULL, 'k' },
+	{ "detached", no_argument, NULL, 'd' },
+	{ "verbose", no_argument, NULL, 'v' },
+	{ "help", no_argument, NULL, 'h' },
+	{ "version", no_argument, NULL, 'V' },
+	{ "engine", required_argument, NULL, 'e'},
+	{ "addcert", required_argument, NULL, 'a'},
+	{ NULL, 0, NULL, 0 },
+};
+
+static void usage(void)
+{
+	printf("Usage: %s [options] --key <keyfile> --cert <certfile> "
+			"<efi-boot-image>\n"
+		"Sign an EFI boot image for use with secure boot.\n\n"
+		"Options:\n"
+		"\t--engine <eng>     use the specified engine to load the key\n"
+		"\t--key <keyfile>    signing key (PEM-encoded RSA "
+						"private key)\n"
+		"\t--cert <certfile>  certificate (x509 certificate)\n"
+		"\t--addcert <addcertfile> additional intermediate certificates in a file\n"
+		"\t--detached         write a detached signature, instead of\n"
+		"\t                    a signed binary\n"
+		"\t--output <file>    write signed data to <file>\n"
+		"\t                    (default <efi-boot-image>.signed,\n"
+		"\t                    or <efi-boot-image>.pk7 for detached\n"
+		"\t                    signatures)\n",
+		toolname);
+}
+
+static void version(void)
+{
+	printf("%s %s\n", toolname, VERSION);
+}
+
+static void set_default_outfilename(struct sign_context *ctx)
+{
+	const char *extension;
+
+	extension = ctx->detached ? "pk7" : "signed";
+
+	ctx->outfilename = talloc_asprintf(ctx, "%s.%s",
+			ctx->infilename, extension);
+}
+
+static int add_intermediate_certs(PKCS7 *p7, const char *filename)
+{
+	STACK_OF(X509_INFO) *certs;
+	X509_INFO *cert;
+	BIO *bio = NULL;
+	int i;
+
+	bio = BIO_new(BIO_s_file());
+	if (!bio || BIO_read_filename(bio, filename) <=0) {
+		fprintf(stderr,
+			"error in reading intermediate certificates file\n");
+		ERR_print_errors_fp(stderr);
+		return -1;
+	}
+
+	certs = PEM_X509_INFO_read_bio(bio, NULL, NULL, NULL);
+	if (!certs) {
+		fprintf(stderr,
+			"error in parsing intermediate certificates file\n");
+		ERR_print_errors_fp(stderr);
+		return -1;
+	}
+
+	for (i = 0; i < sk_X509_INFO_num(certs); i++) {
+		cert = sk_X509_INFO_value(certs, i);
+		PKCS7_add_certificate(p7, cert->x509);
+	}
+
+	sk_X509_INFO_pop_free(certs, X509_INFO_free);
+	BIO_free_all(bio);
+
+	return 0;
+}
+
+int main(int argc, char **argv)
+{
+	const char *keyfilename, *certfilename, *addcertfilename, *engine;
+	struct sign_context *ctx;
+	uint8_t *buf, *tmp;
+	int rc, c, sigsize;
+	EVP_PKEY *pkey;
+
+	ctx = talloc_zero(NULL, struct sign_context);
+
+	keyfilename = NULL;
+	certfilename = NULL;
+	addcertfilename = NULL;
+	engine = NULL;
+
+	for (;;) {
+		int idx;
+		c = getopt_long(argc, argv, "o:c:k:dvVhe:a:", options, &idx);
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'o':
+			ctx->outfilename = talloc_strdup(ctx, optarg);
+			break;
+		case 'c':
+			certfilename = optarg;
+			break;
+		case 'k':
+			keyfilename = optarg;
+			break;
+		case 'd':
+			ctx->detached = 1;
+			break;
+		case 'v':
+			ctx->verbose = 1;
+			break;
+		case 'V':
+			version();
+			return EXIT_SUCCESS;
+		case 'h':
+			usage();
+			return EXIT_SUCCESS;
+		case 'e':
+			engine = optarg;
+			break;
+		case 'a':
+			addcertfilename = optarg;
+			break;
+		}
+	}
+
+	if (argc != optind + 1) {
+		usage();
+		return EXIT_FAILURE;
+	}
+
+	ctx->infilename = argv[optind];
+	if (!ctx->outfilename)
+		set_default_outfilename(ctx);
+
+	if (!certfilename) {
+		fprintf(stderr,
+			"error: No certificate specified (with --cert)\n");
+		usage();
+		return EXIT_FAILURE;
+	}
+	if (!keyfilename) {
+		fprintf(stderr,
+			"error: No key specified (with --key)\n");
+		usage();
+		return EXIT_FAILURE;
+	}
+
+	ctx->image = image_load(ctx->infilename);
+	if (!ctx->image)
+		return EXIT_FAILURE;
+
+	talloc_steal(ctx, ctx->image);
+
+	ERR_load_crypto_strings();
+	ERR_load_BIO_strings();
+	OpenSSL_add_all_digests();
+	OpenSSL_add_all_ciphers();
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+	OPENSSL_config(NULL);
+#else
+	OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, NULL);
+#endif
+	/* here we may get highly unlikely failures or we'll get a
+	 * complaint about FIPS signatures (usually becuase the FIPS
+	 * module isn't present).  In either case ignore the errors
+	 * (malloc will cause other failures out lower down */
+	ERR_clear_error();
+	if (engine)
+		pkey = fileio_read_engine_key(engine, keyfilename);
+	else
+		pkey = fileio_read_pkey(keyfilename);
+	if (!pkey)
+		return EXIT_FAILURE;
+
+	X509 *cert = fileio_read_cert(certfilename);
+	if (!cert)
+		return EXIT_FAILURE;
+
+	const EVP_MD *md = EVP_get_digestbyname("SHA256");
+
+	/* set up the PKCS7 object */
+	PKCS7 *p7 = PKCS7_new();
+	PKCS7_set_type(p7, NID_pkcs7_signed);
+
+	PKCS7_SIGNER_INFO *si = PKCS7_sign_add_signer(p7, cert,
+			pkey, md, PKCS7_BINARY);
+	if (!si) {
+		fprintf(stderr, "error in key/certificate chain\n");
+		ERR_print_errors_fp(stderr);
+		return EXIT_FAILURE;
+	}
+
+	PKCS7_content_new(p7, NID_pkcs7_data);
+
+	rc = IDC_set(p7, si, ctx->image);
+	if (rc)
+		return EXIT_FAILURE;
+
+	if (addcertfilename && add_intermediate_certs(p7, addcertfilename))
+		return EXIT_FAILURE;
+
+	sigsize = i2d_PKCS7(p7, NULL);
+	tmp = buf = talloc_array(ctx->image, uint8_t, sigsize);
+	i2d_PKCS7(p7, &tmp);
+	ERR_print_errors_fp(stdout);
+
+	image_add_signature(ctx->image, buf, sigsize);
+
+	if (ctx->detached) {
+		int i;
+		uint8_t *buf;
+		size_t len;
+
+		for (i = 0; !image_get_signature(ctx->image, i, &buf, &len); i++)
+			;
+		image_write_detached(ctx->image, i - 1, ctx->outfilename);
+	} else
+		image_write(ctx->image, ctx->outfilename);
+
+	talloc_free(ctx);
+
+	return EXIT_SUCCESS;
+}
+
--- tpmsbsigntool-0.9.4.orig/src/verify.c
+++ /dev/null
@@ -1,10 +0,0 @@
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include "image.h"
-
-int main(int argc, char **argv)
-{
-	return EXIT_SUCCESS;
-}
--- tpmsbsigntool-0.9.4.orig/tests/Makefile.am
+++ /dev/null
@@ -1,87 +0,0 @@
-
-AUTOMAKE_OPTIONS = parallel-tests
-
-test_key = private-key.rsa
-test_cert = public-cert.pem
-ca_key = ca-key.ec
-ca_cert = ca-cert.pem
-int_key = int-key.ec
-int_cert = int-cert.pem
-test_arches = $(EFI_ARCH)
-
-check_PROGRAMS = test.pecoff
-
-# override the automake rule to say we build from .elf files
-test.pecoff$(EXEEXT): test.elf
-
-if TEST_BINARY_FORMAT
-EFILDFLAGS = --defsym=EFI_SUBSYSTEM=0x0a
-FORMAT = -O binary
-else
-FORMAT = --target=efi-app-$(EFI_ARCH)
-endif
-check_DATA = $(test_key) $(test_cert)
-check_SCRIPTS = test-wrapper.sh
-
-.elf.pecoff:
-	echo "TEST ARCHES $(test_arches) TEST_COMPAT=$(TEST_COMPAT_FALSE)"
-	$(OBJCOPY) -j .text -j .sdata -j .data \
-		-j .dynamic -j .dynsym  -j .rel \
-		-j .rela -j .reloc \
-		$(FORMAT) $^ $@
-
-.$(OBJEXT).elf:
-	$(LD) $(EFILDFLAGS) -nostdlib -L /usr/lib -L /usr/lib64 -L $(CRTPATH) -shared -Bsymbolic $(CRTPATH)/crt0-efi-$(EFI_ARCH).o -T elf_$(EFI_ARCH)_efi.lds $< -o $@ -lefi -lgnuefi
-
-AM_CFLAGS=-fpic -I/usr/include/efi -I/usr/include/efi/$(EFI_ARCH)
-
-%.rsa: Makefile
-	openssl genrsa -out $@ 2048
-
-%.ec: Makefile
-	openssl genpkey -algorithm ec -pkeyopt ec_paramgen_curve:prime256v1 -out $@
-
-$(ca_cert): $(ca_key) Makefile
-	openssl req -x509 -days 1 -sha256 -subj '/CN=CA Key/' -new -key $< -out $@
-
-$(int_cert): $(int_key) $(ca_cert) Makefile
-	openssl req -new -subj '/CN=Intermediate Certificate/' -key $< -out tmp.req
-	echo -e "[ca]\nbasicConstraints = critical, CA:true\n" > ca.cnf
-	openssl x509 -req -sha256 -CA $(ca_cert) -CAkey $(ca_key) -in tmp.req -set_serial 1 -days 1 -extfile ca.cnf -extensions ca -out $@
-	-rm -f tmp.req ca.cnf
-
-$(test_cert): $(test_key) $(int_cert) Makefile
-	openssl req -new -subj '/CN=Signer Certificate/' -key $< -out tmp.req
-	openssl x509 -req -sha256 -CA $(int_cert) -CAkey $(int_key) -in tmp.req -set_serial 1 -days 1 -out $@
-	-rm -f tmp.req
-
-TESTS = sign-verify.sh \
-	sign-verify-detached.sh \
-	sign-detach-verify.sh \
-	sign-attach-verify.sh \
-	sign-missing-image.sh \
-	sign-missing-cert.sh \
-	sign-missing-key.sh \
-	verify-missing-image.sh \
-	verify-missing-cert.sh \
-	sign-invalidattach-verify.sh \
-	resign-warning.sh \
-	reattach-warning.sh
-
-if !TEST_BINARY_FORMAT
-##
-# These tests involve objdump which will fail because the format
-# is not recognised. Someone needs to fix arm bfd to add efi
-##
-TESTS +=	cert-table-header.sh \
-		detach-remove.sh
-endif
-
-
-TEST_EXTENSIONS = .sh
-AM_TESTS_ENVIRONMENT = TEST_ARCHES='$(test_arches)'; export TEST_ARCHES;
-SH_LOG_COMPILER = $(srcdir)/test-wrapper.sh
-
-EXTRA_DIST = test.S $(TESTS) $(check_SCRIPTS)
-CLEANFILES = $(test_key) $(test_cert) $(int_key) $(int_cert) $(ca_key) \
-	$(ca_cert)
--- tpmsbsigntool-0.9.4.orig/tests/cert-table-header.sh
+++ /dev/null
@@ -1,69 +0,0 @@
-#!/bin/bash -e
-
-# Parse the data directory of a PE/COFF file and returns two hex values:
-# the file offset and size of the signature table.
-function sigtable_params() {
-	filename="$1"
-	objdump -p "$filename" | awk '/^Entry 4/ {print "0x"$3 " " "0x"$4}'
-}
-
-# Extract the signature from a file containing a signature table,
-# and write to stdout
-function extract_sig() {
-	filename="$1"
-	cert_table_header_size=8
-
-	params=($(hexdump -n$cert_table_header_size \
-				-e '/4 "%u " /2 "%04x " /2 "%04x\n"' \
-				"$filename"))
-	cert_size=${params[0]}
-	cert_revision=${params[1]}
-	cert_type=${params[2]}
-
-	# check type & revision
-	[ "$cert_revision" -eq '0200' ]
-	[ "$cert_type" -eq '0002' ]
-
-	dd if="$filename" bs=1 skip=$cert_table_header_size \
-	       count=$(($cert_size - $cert_table_header_size)) 2>/dev/null
-}
-
-function repeat() {
-	str=$1
-	count=$2
-	for (( i = 0; $i < $count; i++ ))
-	do
-		echo -n "$str"
-	done
-}
-
-cert="test.cert"
-signed="test.signed"
-
-for i in {1..8}
-do
-	# generate a variable-length parameter for the certificate subject
-	subj="/CN=$(repeat 'x' $i)"
-
-	# create a temporary cert, and sign the image with it
-	openssl req -x509 -sha256 -subj "$subj" -new -key "$key" -out "$cert"
-	"$sbsign" --cert "$cert" --key "$key" --output "$signed" "$image"
-
-	# extract the sigtable
-	params=($(sigtable_params "$signed"))
-
-	# split and convert to base-10
-	sigtable_offset=$((${params[0]}))
-	sigtable_size=$((${params[1]}))
-
-	# check that we have a correctly-padded sigtable
-	[ $(($sigtable_size % 8)) -eq 0 ]
-
-	sigtable='test.sigtable'
-
-	dd if="$signed" bs=1 skip=$sigtable_offset count=$sigtable_size \
-	       of=$sigtable 2>/dev/null
-
-	# extract sig, and feed to openssl's PKCS7 parser
-	extract_sig "$sigtable" | openssl pkcs7 -inform DER -noout
-done
--- tpmsbsigntool-0.9.4.orig/tests/detach-remove.sh
+++ /dev/null
@@ -1,19 +0,0 @@
-#!/bin/bash -ex
-
-signed="test.signed"
-unsigned="test.unsigned"
-
-"$sbsign" --cert "$cert" --key "$key" --output "$signed" "$image"
-cp "$signed" "$unsigned"
-"$sbattach" --remove "$unsigned"
-
-# ensure that there is no security directory
-objdump -p $unsigned | grep -q '0\+ 0\+ Security Directory'
-
-##
-# somewhat tricky: i386 pecoff binaries can be too short, so we add padding
-# when signing, so make sure the sizes match modulo the padding
-##
-# ensure that the unsigned file is the same size as our original binary
-[ $(( ($(stat --format=%s "$image")+7)&~7)) -eq $(( ($(stat --format=%s "$unsigned")+7)&~7)) ]
-
--- tpmsbsigntool-0.9.4.orig/tests/reattach-warning.sh
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/bash -e
-##
-# The original warning is gone because we now do multiple signatures
-# instead check that the second signature is added
-##
-
-signed="test.signed"
-sig="test.sig"
-
-"$sbsign" --cert "$cert" --key "$key" --detached --output "$sig" "$image"
-cp "$image" "$signed"
-"$sbattach" --attach "$sig" "$signed"
-"$sbattach" --attach "$sig" "$signed" 2>&1 |
-	grep '^Image was already signed; adding additional signature'
--- tpmsbsigntool-0.9.4.orig/tests/resign-warning.sh
+++ /dev/null
@@ -1,11 +0,0 @@
-#!/bin/bash -e
-##
-# The original warning is gone because we now do multiple signatures
-# instead check that the second signature is added
-##
-
-signed="test.signed"
-
-"$sbsign" --cert "$cert" --key "$key" --output "$signed" "$image"
-"$sbsign" --cert "$cert" --key "$key" --output "$signed" "$signed" 2>&1 |
-	grep '^Image was already signed; adding additional signature'
--- tpmsbsigntool-0.9.4.orig/tests/sign-attach-verify.sh
+++ /dev/null
@@ -1,21 +0,0 @@
-#!/bin/bash -e
-
-sig="test.sig"
-signed="test.signed"
-
-"$sbsign" --cert "$cert" --key "$key" --detached --output "$sig" "$image" || exit 1
-cp "$image" "$signed" || exit 1
-"$sbattach" --attach "$sig" "$signed" || exit 1
-"$sbverify" --cert "$cert" "$signed" || exit 1
-"$sbverify" --cert "$intcert" "$signed" || exit 1
-# there's no intermediate cert in the image so it can't chain to the ca which
-# is why this should fail
-"$sbverify" --cert "$cacert" "$signed" && exit 1
-
-# now add intermediates
-"$sbsign" --cert "$cert" --key "$key" --addcert "$intcert" --detached --output "$sig" "$image" || exit 1
-cp "$image" "$signed" || exit 1
-"$sbattach" --attach "$sig" "$signed" || exit 1
-"$sbverify" --cert "$cert" "$signed" || exit 1
-"$sbverify" --cert "$intcert" "$signed" || exit 1
-"$sbverify" --cert "$cacert" "$signed" || exit 1
--- tpmsbsigntool-0.9.4.orig/tests/sign-detach-verify.sh
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/bash -e
-
-signed="test.signed"
-sig="test.sig"
-
-"$sbsign" --cert "$cert" --key "$key" --output "$signed" "$image"
-"$sbattach" --detach "$sig" "$signed"
-"$sbverify" --cert "$cert" --detached $sig "$image"
--- tpmsbsigntool-0.9.4.orig/tests/sign-invalidattach-verify.sh
+++ /dev/null
@@ -1,13 +0,0 @@
-#!/bin/bash -e
-
-invsig="test.invsig"
-dd if=/dev/zero of="$invsig" bs=1 count=1k
-tmp_image=test.pecoff
-cp "$image" "$tmp_image"
-
-set +e
-"$sbattach" --attach "$invsig" "$tmp_image"
-rc=$?
-set -e
-
-test $rc -eq 1
--- tpmsbsigntool-0.9.4.orig/tests/sign-missing-cert.sh
+++ /dev/null
@@ -1,10 +0,0 @@
-#!/bin/bash -e
-
-signed="test.signed"
-
-set +e
-"$sbsign" --cert "missing-cert" --key "$key" --output "$signed" "$image"
-rc=$?
-set -e
-
-test $rc -eq 1
--- tpmsbsigntool-0.9.4.orig/tests/sign-missing-image.sh
+++ /dev/null
@@ -1,10 +0,0 @@
-#!/bin/bash -e
-
-signed="test.signed"
-
-set +e
-"$sbsign" --cert "$cert" --key "$key" --output "$signed" "missing-image"
-rc=$?
-set -e
-
-test $rc -eq 1
--- tpmsbsigntool-0.9.4.orig/tests/sign-missing-key.sh
+++ /dev/null
@@ -1,10 +0,0 @@
-#!/bin/bash -e
-
-signed="test.signed"
-
-set +e
-"$sbsign" --cert "$cert" --key "missing-key" --output "$signed" "$image"
-rc=$?
-set -e
-
-test $rc -eq 1
--- tpmsbsigntool-0.9.4.orig/tests/sign-verify-detached.sh
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/bin/bash -e
-
-sig="test.sig"
-
-"$sbsign" --cert "$cert" --key "$key" --detached --output $sig "$image" || exit 1
-"$sbverify" --cert "$cert" --detached $sig "$image" || exit 1
-"$sbverify" --cert "$intcert" --detached $sig "$image" || exit 1
-# should fail because no intermediate
-"$sbverify" --cert "$cacert" --detached $sig "$image" && exit 1
-
-# now make sure everything succeeds with the intermediate added
-"$sbsign" --cert "$cert" --key "$key" --addcert "$intcert" --detached --output $sig "$image" || exit 1
-"$sbverify" --cert "$cert" --detached $sig "$image" || exit 1
-"$sbverify" --cert "$intcert" --detached $sig "$image" || exit 1
-"$sbverify" --cert "$cacert" --detached $sig "$image" || exit 1
-
-exit 0
--- tpmsbsigntool-0.9.4.orig/tests/sign-verify.sh
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/bin/bash -e
-
-signed="test.signed"
-
-"$sbsign" --cert "$cert" --key "$key" --output "$signed" "$image" || exit 1
-"$sbverify" --cert "$cert" "$signed" || exit 1
-"$sbverify" --cert "$intcert" "$signed" || exit 1
-# there's no intermediate cert in the image so it can't chain to the ca which
-# is why this should fail
-"$sbverify" --cert "$cacert" "$signed" && exit 1
-
-# now add the intermediates and each level should succeed
-"$sbsign" --cert "$cert" --addcert "$intcert" --key "$key" --output "$signed" "$image" || exit 1
-"$sbverify" --cert "$cert" "$signed" || exit 1
-"$sbverify" --cert "$intcert" "$signed" || exit 1
-"$sbverify" --cert "$cacert" "$signed" || exit 1
-
--- tpmsbsigntool-0.9.4.orig/tests/test-wrapper.sh
+++ /dev/null
@@ -1,56 +0,0 @@
-#!/bin/bash
-
-# set a few global variables that may be used by the test
-basedir=$(cd $srcdir && pwd)
-datadir=$(pwd)
-bindir="$datadir/../src"
-
-sbsign=$bindir/sbsign
-sbverify=$bindir/sbverify
-sbattach=$bindir/sbattach
-
-key="$datadir/private-key.rsa"
-cert="$datadir/public-cert.pem"
-intkey="$datadir/int-key.ec"
-intcert="$datadir/int-cert.pem"
-cakey="$datadir/ca-key.ec"
-cacert="$datadir/ca-cert.pem"
-
-export basedir datadir bindir sbsign sbverify sbattach key cert intkey intcert cakey cacert
-
-# 'test' needs to be an absolute path, as we will cd to a temporary
-# directory before running the test
-test="$PWD/$1"
-rc=0
-
-function run_test()
-{
-	test="$1"
-
-	# image depends on the test arch
-	image="$datadir/test.pecoff"
-	export image
-
-	# create the temporary directory...
-	tempdir=$(mktemp --directory)
-
-	# ... and run the test in it.
-	( cd "$tempdir";  $test )
-
-	if [ $? -ne 0 ]
-	then
-		echo "test $(basename $test) failed on arch $arch"
-		echo
-		rc=1
-	fi
-
-	rm -rf "$tempdir"
-}
-
-# run test on all available arches
-for arch in $TEST_ARCHES
-do
-	run_test $test
-done
-
-exit $rc
--- tpmsbsigntool-0.9.4.orig/tests/test.c
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <efi.h>
-#include <efilib.h>
-
-EFI_STATUS
-efi_main (EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
-{
-	return EFI_SUCCESS;
-}
--- tpmsbsigntool-0.9.4.orig/tests/verify-missing-cert.sh
+++ /dev/null
@@ -1,12 +0,0 @@
-#!/bin/bash -e
-
-signed="test.signed"
-
-"$sbsign" --cert "$cert" --key "$key" --output "$signed" "$image"
-
-set +e
-"$sbverify" --cert "missing-cert" "$signed"
-rc=$?
-set -e
-
-test $rc -eq 1
--- tpmsbsigntool-0.9.4.orig/tests/verify-missing-image.sh
+++ /dev/null
@@ -1,10 +0,0 @@
-#!/bin/bash -e
-
-signed="test.signed"
-
-set +e
-"$sbverify" "missing-image"
-rc=$?
-set -e
-
-test $rc -eq 1
